(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[38],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.js ***!
  \****************************************************************************/
/*! exports provided: conf, language */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conf\", function() { return conf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"language\", function() { return language; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar conf = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\#\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g,\n    comments: {\n        lineComment: '//',\n        blockComment: ['{', '}']\n    },\n    brackets: [\n        ['{', '}'],\n        ['[', ']'],\n        ['(', ')'],\n        ['<', '>']\n    ],\n    autoClosingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: '<', close: '>' },\n        { open: \"'\", close: \"'\" }\n    ],\n    surroundingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: '<', close: '>' },\n        { open: \"'\", close: \"'\" }\n    ],\n    folding: {\n        markers: {\n            start: new RegExp(\"^\\\\s*\\\\{\\\\$REGION(\\\\s\\\\'.*\\\\')?\\\\}\"),\n            end: new RegExp('^\\\\s*\\\\{\\\\$ENDREGION\\\\}')\n        }\n    }\n};\nvar language = {\n    defaultToken: '',\n    tokenPostfix: '.pascal',\n    ignoreCase: true,\n    brackets: [\n        { open: '{', close: '}', token: 'delimiter.curly' },\n        { open: '[', close: ']', token: 'delimiter.square' },\n        { open: '(', close: ')', token: 'delimiter.parenthesis' },\n        { open: '<', close: '>', token: 'delimiter.angle' }\n    ],\n    keywords: [\n        'absolute',\n        'abstract',\n        'all',\n        'and_then',\n        'array',\n        'as',\n        'asm',\n        'attribute',\n        'begin',\n        'bindable',\n        'case',\n        'class',\n        'const',\n        'contains',\n        'default',\n        'div',\n        'else',\n        'end',\n        'except',\n        'exports',\n        'external',\n        'far',\n        'file',\n        'finalization',\n        'finally',\n        'forward',\n        'generic',\n        'goto',\n        'if',\n        'implements',\n        'import',\n        'in',\n        'index',\n        'inherited',\n        'initialization',\n        'interrupt',\n        'is',\n        'label',\n        'library',\n        'mod',\n        'module',\n        'name',\n        'near',\n        'not',\n        'object',\n        'of',\n        'on',\n        'only',\n        'operator',\n        'or_else',\n        'otherwise',\n        'override',\n        'package',\n        'packed',\n        'pow',\n        'private',\n        'program',\n        'protected',\n        'public',\n        'published',\n        'interface',\n        'implementation',\n        'qualified',\n        'read',\n        'record',\n        'resident',\n        'requires',\n        'resourcestring',\n        'restricted',\n        'segment',\n        'set',\n        'shl',\n        'shr',\n        'specialize',\n        'stored',\n        'then',\n        'threadvar',\n        'to',\n        'try',\n        'type',\n        'unit',\n        'uses',\n        'var',\n        'view',\n        'virtual',\n        'dynamic',\n        'overload',\n        'reintroduce',\n        'with',\n        'write',\n        'xor',\n        'true',\n        'false',\n        'procedure',\n        'function',\n        'constructor',\n        'destructor',\n        'property',\n        'break',\n        'continue',\n        'exit',\n        'abort',\n        'while',\n        'do',\n        'for',\n        'raise',\n        'repeat',\n        'until'\n    ],\n    typeKeywords: [\n        'boolean',\n        'double',\n        'byte',\n        'integer',\n        'shortint',\n        'char',\n        'longint',\n        'float',\n        'string'\n    ],\n    operators: [\n        '=',\n        '>',\n        '<',\n        '<=',\n        '>=',\n        '<>',\n        ':',\n        ':=',\n        'and',\n        'or',\n        '+',\n        '-',\n        '*',\n        '/',\n        '@',\n        '&',\n        '^',\n        '%'\n    ],\n    // we include these common regular expressions\n    symbols: /[=><:@\\^&|+\\-*\\/\\^%]+/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // identifiers and keywords\n            [\n                /[a-zA-Z_][\\w]*/,\n                {\n                    cases: {\n                        '@keywords': { token: 'keyword.$0' },\n                        '@default': 'identifier'\n                    }\n                }\n            ],\n            // whitespace\n            { include: '@whitespace' },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, '@brackets'],\n            [/[<>](?!@symbols)/, '@brackets'],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        '@operators': 'delimiter',\n                        '@default': ''\n                    }\n                }\n            ],\n            // numbers\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?/, 'number.float'],\n            [/\\$[0-9a-fA-F]{1,16}/, 'number.hex'],\n            [/\\d+/, 'number'],\n            // delimiter: after number because of .\\d floats\n            [/[;,.]/, 'delimiter'],\n            // strings\n            [/'([^'\\\\]|\\\\.)*$/, 'string.invalid'],\n            [/'/, 'string', '@string'],\n            // characters\n            [/'[^\\\\']'/, 'string'],\n            [/'/, 'string.invalid'],\n            [/\\#\\d+/, 'string']\n        ],\n        comment: [\n            [/[^\\*\\}]+/, 'comment'],\n            //[/\\(\\*/,    'comment', '@push' ],    // nested comment  not allowed :-(\n            [/\\}/, 'comment', '@pop'],\n            [/[\\{]/, 'comment']\n        ],\n        string: [\n            [/[^\\\\']+/, 'string'],\n            [/\\\\./, 'string.escape.invalid'],\n            [/'/, { token: 'string.quote', bracket: '@close', next: '@pop' }]\n        ],\n        whitespace: [\n            [/[ \\t\\r\\n]+/, 'white'],\n            [/\\{/, 'comment', '@comment'],\n            [/\\/\\/.*$/, 'comment']\n        ]\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.js?");

/***/ })

}]);