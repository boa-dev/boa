diff --git a/core/ast/src/declaration/export.rs b/core/ast/src/declaration/export.rs
index cb7c1065..470fd411 100644
--- a/core/ast/src/declaration/export.rs
+++ b/core/ast/src/declaration/export.rs
@@ -9,7 +9,7 @@
 //! [spec]: https://tc39.es/ecma262/#sec-exports
 //! [mdn]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export

-use super::{ModuleSpecifier, VarDeclaration};
+use super::{ImportAttribute, ModuleSpecifier, VarDeclaration};
 use crate::{
     Declaration, Expression,
     function::{
@@ -87,6 +87,8 @@ pub enum ExportDeclaration {
         kind: ReExportKind,
         /// Reexported module specifier.
         specifier: ModuleSpecifier,
+        /// Re-export attributes.
+        attributes: Box<[ImportAttribute]>,
     },
     /// List of exports.
     List(Box<[ExportSpecifier]>),
@@ -114,9 +116,17 @@ impl VisitWith for ExportDeclaration {
         V: Visitor<'a>,
     {
         match self {
-            Self::ReExport { specifier, kind } => {
+            Self::ReExport {
+                specifier,
+                kind,
+                attributes,
+            } => {
                 visitor.visit_module_specifier(specifier)?;
-                visitor.visit_re_export_kind(kind)
+                visitor.visit_re_export_kind(kind)?;
+                for attribute in &**attributes {
+                    visitor.visit_import_attribute(attribute)?;
+                }
+                ControlFlow::Continue(())
             }
             Self::List(list) => {
                 for item in &**list {
@@ -144,9 +154,17 @@ impl VisitWith for ExportDeclaration {
         V: VisitorMut<'a>,
     {
         match self {
-            Self::ReExport { specifier, kind } => {
+            Self::ReExport {
+                specifier,
+                kind,
+                attributes,
+            } => {
                 visitor.visit_module_specifier_mut(specifier)?;
-                visitor.visit_re_export_kind_mut(kind)
+                visitor.visit_re_export_kind_mut(kind)?;
+                for attribute in &mut **attributes {
+                    visitor.visit_import_attribute_mut(attribute)?;
+                }
+                ControlFlow::Continue(())
             }
             Self::List(list) => {
                 for item in &mut **list {
@@ -253,7 +271,7 @@ pub enum ReExportImportName {
 /// [`ExportEntry`][spec] record.
 ///
 /// [spec]: https://tc39.es/ecma262/#table-exportentry-records
-#[derive(Debug, Clone, Copy)]
+#[derive(Debug, Clone)]
 pub enum ExportEntry {
     /// An ordinary export entry
     Ordinary(LocalExportEntry),
@@ -261,6 +279,8 @@ pub enum ExportEntry {
     StarReExport {
         /// The module from where this reexport will import.
         module_request: Sym,
+        /// The import attributes for this reexport.
+        attributes: Box<[ImportAttribute]>,
     },
     /// A reexport entry with an export name.
     ReExport(IndirectExportEntry),
@@ -309,25 +329,28 @@ impl LocalExportEntry {
 }

 /// A reexported export entry.
-#[derive(Debug, Clone, Copy)]
+#[derive(Debug, Clone)]
 pub struct IndirectExportEntry {
     module_request: Sym,
     import_name: ReExportImportName,
     export_name: Sym,
+    attributes: Box<[ImportAttribute]>,
 }

 impl IndirectExportEntry {
     /// Creates a new `IndirectExportEntry`.
     #[must_use]
-    pub const fn new(
+    pub fn new(
         module_request: Sym,
         import_name: ReExportImportName,
         export_name: Sym,
+        attributes: Box<[ImportAttribute]>,
     ) -> Self {
         Self {
             module_request,
             import_name,
             export_name,
+            attributes,
         }
     }

@@ -348,4 +371,10 @@ impl IndirectExportEntry {
     pub const fn export_name(&self) -> Sym {
         self.export_name
     }
+
+    /// Gets the import attributes.
+    #[must_use]
+    pub fn attributes(&self) -> &[ImportAttribute] {
+        &self.attributes
+    }
 }
diff --git a/core/ast/src/declaration/import.rs b/core/ast/src/declaration/import.rs
index 4369e2e9..1d908220 100644
--- a/core/ast/src/declaration/import.rs
+++ b/core/ast/src/declaration/import.rs
@@ -17,7 +17,7 @@ use crate::{
 };
 use boa_interner::Sym;

-use super::ModuleSpecifier;
+use super::{ImportAttribute, ModuleSpecifier};

 /// The kind of import in an [`ImportDeclaration`].
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
@@ -87,21 +87,25 @@ pub struct ImportDeclaration {
     kind: ImportKind,
     /// Module specifier.
     specifier: ModuleSpecifier,
+    /// Import attributes.
+    attributes: Box<[ImportAttribute]>,
 }

 impl ImportDeclaration {
     /// Creates a new import declaration.
     #[inline]
     #[must_use]
-    pub const fn new(
+    pub fn new(
         default: Option<Identifier>,
         kind: ImportKind,
         specifier: ModuleSpecifier,
+        attributes: Box<[ImportAttribute]>,
     ) -> Self {
         Self {
             default,
             kind,
             specifier,
+            attributes,
         }
     }

@@ -119,12 +123,19 @@ impl ImportDeclaration {
         self.specifier
     }

-    /// Gets the import kind of the import declaration
+    /// Gets the import kind of the import declaration.
     #[inline]
     #[must_use]
     pub const fn kind(&self) -> &ImportKind {
         &self.kind
     }
+
+    /// Gets the import attributes of the import declaration.
+    #[inline]
+    #[must_use]
+    pub const fn attributes(&self) -> &[ImportAttribute] {
+        &self.attributes
+    }
 }

 impl VisitWith for ImportDeclaration {
@@ -136,7 +147,11 @@ impl VisitWith for ImportDeclaration {
             visitor.visit_identifier(default)?;
         }
         visitor.visit_import_kind(&self.kind)?;
-        visitor.visit_module_specifier(&self.specifier)
+        visitor.visit_module_specifier(&self.specifier)?;
+        for attribute in &*self.attributes {
+            visitor.visit_import_attribute(attribute)?;
+        }
+        ControlFlow::Continue(())
     }

     fn visit_with_mut<'a, V>(&'a mut self, visitor: &mut V) -> ControlFlow<V::BreakTy>
@@ -147,7 +162,11 @@ impl VisitWith for ImportDeclaration {
             visitor.visit_identifier_mut(default)?;
         }
         visitor.visit_import_kind_mut(&mut self.kind)?;
-        visitor.visit_module_specifier_mut(&mut self.specifier)
+        visitor.visit_module_specifier_mut(&mut self.specifier)?;
+        for attribute in &mut *self.attributes {
+            visitor.visit_import_attribute_mut(attribute)?;
+        }
+        ControlFlow::Continue(())
     }
 }

@@ -221,21 +240,28 @@ pub enum ImportName {
 /// [`ImportEntry`][spec] record.
 ///
 /// [spec]: https://tc39.es/ecma262/#table-importentry-record-fields
-#[derive(Debug, Clone, Copy)]
+#[derive(Debug, Clone)]
 pub struct ImportEntry {
     module_request: Sym,
     import_name: ImportName,
     local_name: Identifier,
+    attributes: Box<[ImportAttribute]>,
 }

 impl ImportEntry {
     /// Creates a new `ImportEntry`.
     #[must_use]
-    pub const fn new(module_request: Sym, import_name: ImportName, local_name: Identifier) -> Self {
+    pub fn new(
+        module_request: Sym,
+        import_name: ImportName,
+        local_name: Identifier,
+        attributes: Box<[ImportAttribute]>,
+    ) -> Self {
         Self {
             module_request,
             import_name,
             local_name,
+            attributes,
         }
     }

@@ -256,4 +282,10 @@ impl ImportEntry {
     pub const fn local_name(&self) -> Identifier {
         self.local_name
     }
+
+    /// Gets the import attributes.
+    #[must_use]
+    pub fn attributes(&self) -> &[ImportAttribute] {
+        &self.attributes
+    }
 }
diff --git a/core/ast/src/declaration/mod.rs b/core/ast/src/declaration/mod.rs
index 4f8f5132..53bb54b7 100644
--- a/core/ast/src/declaration/mod.rs
+++ b/core/ast/src/declaration/mod.rs
@@ -156,3 +156,61 @@ impl VisitWith for ModuleSpecifier {
         visitor.visit_sym_mut(&mut self.module)
     }
 }
+
+/// An import attribute entry in an [`ImportDeclaration`].
+///
+/// This is a key-value pair, where the key is an identifier or string literal,
+/// and the value is a string literal.
+///
+/// More information:
+///  - [ECMAScript specification][spec]
+///
+/// [spec]: https://tc39.es/ecma262/#sec-imports
+#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
+#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
+#[derive(Clone, Debug, Copy, PartialEq, Eq)]
+pub struct ImportAttribute {
+    key: Sym,
+    value: Sym,
+}
+
+impl ImportAttribute {
+    /// Creates a new `ImportAttribute`.
+    #[inline]
+    #[must_use]
+    pub const fn new(key: Sym, value: Sym) -> Self {
+        Self { key, value }
+    }
+
+    /// Gets the attribute key.
+    #[inline]
+    #[must_use]
+    pub const fn key(self) -> Sym {
+        self.key
+    }
+
+    /// Gets the attribute value.
+    #[inline]
+    #[must_use]
+    pub const fn value(self) -> Sym {
+        self.value
+    }
+}
+
+impl VisitWith for ImportAttribute {
+    fn visit_with<'a, V>(&'a self, visitor: &mut V) -> ControlFlow<V::BreakTy>
+    where
+        V: Visitor<'a>,
+    {
+        visitor.visit_sym(&self.key)?;
+        visitor.visit_sym(&self.value)
+    }
+
+    fn visit_with_mut<'a, V>(&'a mut self, visitor: &mut V) -> ControlFlow<V::BreakTy>
+    where
+        V: VisitorMut<'a>,
+    {
+        visitor.visit_sym_mut(&mut self.key)?;
+        visitor.visit_sym_mut(&mut self.value)
+    }
+}
diff --git a/core/ast/src/expression/call.rs b/core/ast/src/expression/call.rs
index d2a9058d..7fa9ec77 100644
--- a/core/ast/src/expression/call.rs
+++ b/core/ast/src/expression/call.rs
@@ -196,26 +196,53 @@ impl VisitWith for SuperCall {
 #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
 #[derive(Clone, Debug, PartialEq)]
 pub struct ImportCall {
-    arg: Box<Expression>,
+    specifier: Box<Expression>,
+    options: Option<Box<Expression>>,
     span: Span,
 }

 impl ImportCall {
     /// Creates a new `ImportCall` AST node.
-    pub fn new<A>(arg: A, span: Span) -> Self
+    #[inline]
+    #[must_use]
+    pub fn new<S>(specifier: S, options: Option<Expression>, span: Span) -> Self
     where
-        A: Into<Expression>,
+        S: Into<Expression>,
     {
         Self {
-            arg: Box::new(arg.into()),
+            specifier: Box::new(specifier.into()),
+            options: options.map(Box::new),
             span,
         }
     }

-    /// Retrieves the single argument of the import call.
+    /// Retrieves the specifier (first argument) of the import call.
+    #[inline]
+    #[must_use]
+    pub const fn specifier(&self) -> &Expression {
+        &self.specifier
+    }
+
+    /// Retrieves the options (second argument) of the import call, if present.
+    ///
+    /// This is used for import attributes:
+    /// ```js
+    /// import("foo.json", { with: { type: "json" } })
+    /// ```
+    #[inline]
+    #[must_use]
+    pub fn options(&self) -> Option<&Expression> {
+        self.options.as_deref()
+    }
+
+    /// Gets the module specifier of the import call.
+    ///
+    /// This is an alias for [`Self::specifier`] for backwards compatibility.
+    #[inline]
     #[must_use]
+    #[deprecated(since = "0.21.0", note = "use `specifier` instead")]
     pub const fn argument(&self) -> &Expression {
-        &self.arg
+        &self.specifier
     }
 }

@@ -229,7 +256,15 @@ impl Spanned for ImportCall {
 impl ToInternedString for ImportCall {
     #[inline]
     fn to_interned_string(&self, interner: &Interner) -> String {
-        format!("import({})", self.arg.to_interned_string(interner))
+        if let Some(options) = &self.options {
+            format!(
+                "import({}, {})",
+                self.specifier.to_interned_string(interner),
+                options.to_interned_string(interner)
+            )
+        } else {
+            format!("import({})", self.specifier.to_interned_string(interner))
+        }
     }
 }

@@ -245,13 +280,21 @@ impl VisitWith for ImportCall {
     where
         V: Visitor<'a>,
     {
-        visitor.visit_expression(&self.arg)
+        visitor.visit_expression(&self.specifier)?;
+        if let Some(options) = &self.options {
+            visitor.visit_expression(options)?;
+        }
+        ControlFlow::Continue(())
     }

     fn visit_with_mut<'a, V>(&'a mut self, visitor: &mut V) -> ControlFlow<V::BreakTy>
     where
         V: VisitorMut<'a>,
     {
-        visitor.visit_expression_mut(&mut self.arg)
+        visitor.visit_expression_mut(&mut self.specifier)?;
+        if let Some(options) = &mut self.options {
+            visitor.visit_expression_mut(options)?;
+        }
+        ControlFlow::Continue(())
     }
 }
diff --git a/core/ast/src/module_item_list/mod.rs b/core/ast/src/module_item_list/mod.rs
index 4f0ff9b6..985a16ae 100644
--- a/core/ast/src/module_item_list/mod.rs
+++ b/core/ast/src/module_item_list/mod.rs
@@ -8,9 +8,9 @@
 use crate::{
     StatementListItem,
     declaration::{
-        ExportDeclaration, ExportEntry, ExportSpecifier, ImportDeclaration, ImportEntry,
-        ImportKind, ImportName, IndirectExportEntry, LocalExportEntry, ModuleSpecifier,
-        ReExportImportName, ReExportKind,
+        ExportDeclaration, ExportEntry, ExportSpecifier, ImportAttribute, ImportDeclaration,
+        ImportEntry, ImportKind, ImportName, IndirectExportEntry, LocalExportEntry,
+        ModuleSpecifier, ReExportImportName, ReExportKind,
     },
     operations::{BoundNamesVisitor, bound_names},
     visitor::{VisitWith, Visitor, VisitorMut},
@@ -258,20 +258,26 @@ impl ModuleItemList {
                 node: &'ast ImportDeclaration,
             ) -> ControlFlow<Self::BreakTy> {
                 let module = node.specifier().sym();
+                let attributes: Box<[ImportAttribute]> = Box::from(node.attributes());

                 if let Some(default) = node.default() {
                     self.0.push(ImportEntry::new(
                         module,
                         ImportName::Name(Sym::DEFAULT),
                         default,
+                        attributes.clone(),
                     ));
                 }

                 match node.kind() {
                     ImportKind::DefaultOrUnnamed => {}
                     ImportKind::Namespaced { binding } => {
-                        self.0
-                            .push(ImportEntry::new(module, ImportName::Namespace, *binding));
+                        self.0.push(ImportEntry::new(
+                            module,
+                            ImportName::Namespace,
+                            *binding,
+                            attributes.clone(),
+                        ));
                     }
                     ImportKind::Named { names } => {
                         for name in &**names {
@@ -279,6 +285,7 @@ impl ModuleItemList {
                                 module,
                                 ImportName::Name(name.export_name()),
                                 name.binding(),
+                                attributes.clone(),
                             ));
                         }
                     }
@@ -323,8 +330,13 @@ impl ModuleItemList {
                 node: &'ast ExportDeclaration,
             ) -> ControlFlow<Self::BreakTy> {
                 let name = match node {
-                    ExportDeclaration::ReExport { kind, specifier } => {
+                    ExportDeclaration::ReExport {
+                        kind,
+                        specifier,
+                        attributes,
+                    } => {
                         let module = specifier.sym();
+                        let attrs = attributes.clone();

                         match kind {
                             ReExportKind::Namespaced { name: Some(name) } => {
@@ -333,6 +345,7 @@ impl ModuleItemList {
                                         module,
                                         ReExportImportName::Star,
                                         *name,
+                                        attrs.clone(),
                                     )
                                     .into(),
                                 );
@@ -340,6 +353,7 @@ impl ModuleItemList {
                             ReExportKind::Namespaced { name: None } => {
                                 self.0.push(ExportEntry::StarReExport {
                                     module_request: module,
+                                    attributes: attrs.clone(),
                                 });
                             }

@@ -350,6 +364,7 @@ impl ModuleItemList {
                                             module,
                                             ReExportImportName::Name(name.private_name()),
                                             name.alias(),
+                                            attrs.clone(),
                                         )
                                         .into(),
                                     );
diff --git a/core/ast/src/scope_analyzer.rs b/core/ast/src/scope_analyzer.rs
index 73e7abb2..56875874 100644
--- a/core/ast/src/scope_analyzer.rs
+++ b/core/ast/src/scope_analyzer.rs
@@ -490,7 +490,9 @@ impl<'ast> VisitorMut<'ast> for BindingEscapeAnalyzer<'_> {
         node: &'ast mut ExportDeclaration,
     ) -> ControlFlow<Self::BreakTy> {
         match node {
-            ExportDeclaration::ReExport { specifier, kind } => {
+            ExportDeclaration::ReExport {
+                specifier, kind, ..
+            } => {
                 self.visit_module_specifier_mut(specifier)?;
                 self.visit_re_export_kind_mut(kind)
             }
diff --git a/core/ast/src/visitor.rs b/core/ast/src/visitor.rs
index ef433405..396a95ba 100644
--- a/core/ast/src/visitor.rs
+++ b/core/ast/src/visitor.rs
@@ -8,9 +8,9 @@ use std::ops::ControlFlow;
 use crate::{
     Module, ModuleItem, ModuleItemList, Script, StatementList, StatementListItem,
     declaration::{
-        Binding, Declaration, ExportDeclaration, ExportSpecifier, ImportDeclaration, ImportKind,
-        ImportSpecifier, LexicalDeclaration, ModuleSpecifier, ReExportKind, VarDeclaration,
-        Variable, VariableList,
+        Binding, Declaration, ExportDeclaration, ExportSpecifier, ImportAttribute,
+        ImportDeclaration, ImportKind, ImportSpecifier, LexicalDeclaration, ModuleSpecifier,
+        ReExportKind, VarDeclaration, Variable, VariableList,
     },
     expression::{
         Await, Call, Expression, Identifier, ImportCall, ImportMeta, New, NewTarget, Optional,
@@ -209,12 +209,13 @@ node_ref! {
     ModuleItemList,
     ModuleItem,
     ModuleSpecifier,
+    ImportAttribute,
     ImportKind,
     ImportDeclaration,
     ImportSpecifier,
     ReExportKind,
     ExportDeclaration,
-    ExportSpecifier
+    ExportSpecifier,
 }

 /// Represents an AST visitor.
@@ -321,6 +322,7 @@ pub trait Visitor<'ast>: Sized {
     define_visit!(visit_module_item_list, ModuleItemList);
     define_visit!(visit_module_item, ModuleItem);
     define_visit!(visit_module_specifier, ModuleSpecifier);
+    define_visit!(visit_import_attribute, ImportAttribute);
     define_visit!(visit_import_kind, ImportKind);
     define_visit!(visit_import_declaration, ImportDeclaration);
     define_visit!(visit_import_specifier, ImportSpecifier);
@@ -430,6 +432,7 @@ pub trait Visitor<'ast>: Sized {
             NodeRef::ModuleItemList(n) => self.visit_module_item_list(n),
             NodeRef::ModuleItem(n) => self.visit_module_item(n),
             NodeRef::ModuleSpecifier(n) => self.visit_module_specifier(n),
+            NodeRef::ImportAttribute(n) => self.visit_import_attribute(n),
             NodeRef::ImportKind(n) => self.visit_import_kind(n),
             NodeRef::ImportDeclaration(n) => self.visit_import_declaration(n),
             NodeRef::ImportSpecifier(n) => self.visit_import_specifier(n),
@@ -553,6 +556,7 @@ pub trait VisitorMut<'ast>: Sized {
     define_visit_mut!(visit_module_item_list_mut, ModuleItemList);
     define_visit_mut!(visit_module_item_mut, ModuleItem);
     define_visit_mut!(visit_module_specifier_mut, ModuleSpecifier);
+    define_visit_mut!(visit_import_attribute_mut, ImportAttribute);
     define_visit_mut!(visit_import_kind_mut, ImportKind);
     define_visit_mut!(visit_import_declaration_mut, ImportDeclaration);
     define_visit_mut!(visit_import_specifier_mut, ImportSpecifier);
@@ -664,6 +668,7 @@ pub trait VisitorMut<'ast>: Sized {
             NodeRefMut::ModuleItemList(n) => self.visit_module_item_list_mut(n),
             NodeRefMut::ModuleItem(n) => self.visit_module_item_mut(n),
             NodeRefMut::ModuleSpecifier(n) => self.visit_module_specifier_mut(n),
+            NodeRefMut::ImportAttribute(n) => self.visit_import_attribute_mut(n),
             NodeRefMut::ImportKind(n) => self.visit_import_kind_mut(n),
             NodeRefMut::ImportDeclaration(n) => self.visit_import_declaration_mut(n),
             NodeRefMut::ImportSpecifier(n) => self.visit_import_specifier_mut(n),
diff --git a/core/engine/src/bytecompiler/expression/mod.rs b/core/engine/src/bytecompiler/expression/mod.rs
index 74fd39bb..89d66911 100644
--- a/core/engine/src/bytecompiler/expression/mod.rs
+++ b/core/engine/src/bytecompiler/expression/mod.rs
@@ -406,8 +406,16 @@ impl ByteCompiler<'_> {
                 self.bytecode.emit_bind_this_value(dst.variable());
             }
             Expression::ImportCall(import) => {
-                self.compile_expr(import.argument(), dst);
-                self.bytecode.emit_import_call(dst.variable());
+                self.compile_expr(import.specifier(), dst);
+                let options = self.register_allocator.alloc();
+                if let Some(opts) = import.options() {
+                    self.compile_expr(opts, &options);
+                } else {
+                    self.bytecode.emit_push_undefined(options.variable());
+                }
+                self.bytecode
+                    .emit_import_call(dst.variable(), options.variable());
+                self.register_allocator.dealloc(options);
             }
             Expression::NewTarget(_new_target) => {
                 self.bytecode.emit_new_target(dst.variable());
diff --git a/core/engine/src/module/loader/embedded.rs b/core/engine/src/module/loader/embedded.rs
index 542633b4..e3b79f9f 100644
--- a/core/engine/src/module/loader/embedded.rs
+++ b/core/engine/src/module/loader/embedded.rs
@@ -141,13 +141,13 @@ impl ModuleLoader for EmbeddedModuleLoader {
     fn load_imported_module(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: boa_engine::module::ModuleRequest,
         context: &RefCell<&mut Context>,
     ) -> impl Future<Output = JsResult<Module>> {
         let result = (|| {
             let specifier_path = boa_engine::module::resolve_module_specifier(
                 None,
-                &specifier,
+                request.specifier(),
                 referrer.path(),
                 &mut context.borrow_mut(),
             )
@@ -155,7 +155,7 @@ impl ModuleLoader for EmbeddedModuleLoader {
                 JsNativeError::typ()
                     .with_message(format!(
                         "could not resolve module specifier `{}`",
-                        specifier.display_escaped()
+                        request.specifier().display_escaped()
                     ))
                     .with_cause(e)
             })?;
@@ -166,7 +166,7 @@ impl ModuleLoader for EmbeddedModuleLoader {
                 .ok_or_else(|| {
                     JsNativeError::typ().with_message(format!(
                         "could not find module `{}`",
-                        specifier.display_escaped()
+                        request.specifier().display_escaped()
                     ))
                 })?;

diff --git a/core/engine/src/module/loader/mod.rs b/core/engine/src/module/loader/mod.rs
index db60b338..71fd9618 100644
--- a/core/engine/src/module/loader/mod.rs
+++ b/core/engine/src/module/loader/mod.rs
@@ -178,7 +178,7 @@ pub trait ModuleLoader: Any {
     async fn load_imported_module(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: super::ModuleRequest,
         context: &RefCell<&mut Context>,
     ) -> JsResult<Module>;

@@ -209,9 +209,9 @@ pub(crate) trait DynModuleLoader: Any {
     fn load_imported_module<'a, 'b, 'fut>(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: super::ModuleRequest,
         context: &'a RefCell<&'b mut Context>,
-    ) -> Fn!(Rc<Self>, Referrer, JsString, &'a RefCell<&'b mut Context> => dyn 'fut + Future<Output = JsResult<Module>>)
+    ) -> Fn!(Rc<Self>, Referrer, super::ModuleRequest, &'a RefCell<&'b mut Context> => dyn 'fut + Future<Output = JsResult<Module>>)
     where
         'a: 'fut,
         'b: 'fut;
@@ -229,14 +229,14 @@ impl<T: ModuleLoader> DynModuleLoader for T {
     fn load_imported_module<'a, 'b, 'fut>(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: super::ModuleRequest,
         context: &'a RefCell<&'b mut Context>,
-    ) -> Fn!(Rc<Self>, Referrer, JsString, &'a RefCell<&'b mut Context> => dyn 'fut + Future<Output = JsResult<Module>>)
+    ) -> Fn!(Rc<Self>, Referrer, super::ModuleRequest, &'a RefCell<&'b mut Context> => dyn 'fut + Future<Output = JsResult<Module>>)
     where
         'a: 'fut,
         'b: 'fut,
     {
-        from_fn!(T::load_imported_module, self, referrer, specifier, context)
+        from_fn!(T::load_imported_module, self, referrer, request, context)
     }

     fn init_import_meta(
@@ -259,7 +259,7 @@ impl ModuleLoader for IdleModuleLoader {
     async fn load_imported_module(
         self: Rc<Self>,
         _referrer: Referrer,
-        _specifier: JsString,
+        _request: super::ModuleRequest,
         _context: &RefCell<&mut Context>,
     ) -> JsResult<Module> {
         Err(JsNativeError::typ()
@@ -317,13 +317,13 @@ impl ModuleLoader for MapModuleLoader {
     fn load_imported_module(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: super::ModuleRequest,
         context: &RefCell<&mut Context>,
     ) -> impl Future<Output = JsResult<Module>> {
         let result = (|| {
             let path = resolve_module_specifier(
                 None,
-                &specifier,
+                request.specifier(),
                 referrer.path(),
                 &mut context.borrow_mut(),
             )?;
@@ -377,43 +377,127 @@ impl SimpleModuleLoader {
         self.module_map.borrow_mut().insert(path, module);
     }

+    /// Inserts a new module onto the module map with the given attributes.
+    ///
+    /// This is an alias for `insert` in this implementation, as it ignores attributes.
+    #[inline]
+    pub fn insert_with_attributes(
+        &self,
+        path: PathBuf,
+        _attributes: &[(JsString, JsString)],
+        module: Module,
+    ) {
+        self.insert(path, module);
+    }
+
     /// Gets a module from its original path.
     #[inline]
     pub fn get(&self, path: &Path) -> Option<Module> {
         self.module_map.borrow().get(path).cloned()
     }
+
+    /// Gets a module from its original path and attributes.
+    ///
+    /// This is an alias for `get` in this implementation, as it ignores attributes.
+    #[inline]
+    pub fn get_with_attributes(
+        &self,
+        path: &Path,
+        _attributes: &[(JsString, JsString)],
+    ) -> Option<Module> {
+        self.get(path)
+    }
 }

 impl ModuleLoader for SimpleModuleLoader {
     fn load_imported_module(
         self: Rc<Self>,
         referrer: Referrer,
-        specifier: JsString,
+        request: super::ModuleRequest,
         context: &RefCell<&mut Context>,
     ) -> impl Future<Output = JsResult<Module>> {
         let result = (|| {
-            let short_path = specifier.to_std_string_escaped();
+            let short_path = request.specifier().to_std_string_escaped();
             let path = resolve_module_specifier(
                 Some(&self.root),
-                &specifier,
+                request.specifier(),
                 referrer.path(),
                 &mut context.borrow_mut(),
             )?;
-            if let Some(module) = self.get(&path) {
+
+            if let Some(module) = self.get_with_attributes(&path, request.attributes()) {
                 return Ok(module);
             }

-            let source = Source::from_filepath(&path).map_err(|err| {
-                JsNativeError::typ()
-                    .with_message(format!("could not open file `{short_path}`"))
-                    .with_cause(JsError::from_opaque(js_string!(err.to_string()).into()))
-            })?;
-            let module = Module::parse(source, None, &mut context.borrow_mut()).map_err(|err| {
-                JsNativeError::syntax()
-                    .with_message(format!("could not parse module `{short_path}`"))
-                    .with_cause(err)
-            })?;
-            self.insert(path, module.clone());
+            // Check for import attribute type
+            let mut module_type = None;
+            let type_key = js_string!("type");
+            for (key, value) in request.attributes() {
+                if key == &type_key {
+                    module_type = Some(value);
+                }
+            }
+
+            if path
+                .extension()
+                .is_some_and(|ext| ext.to_string_lossy() == "json")
+            {
+                let is_json_type = module_type.is_some_and(|t| t == &js_string!("json"));
+                if !is_json_type {
+                    return Err(JsNativeError::typ()
+                        .with_message(format!(
+                            "module `{short_path}` needs an import attribute of type \"json\""
+                        ))
+                        .into());
+                }
+            }
+            let module = if let Some(ty) = module_type {
+                // Handle different module types based on the type attribute
+                match ty.to_std_string_escaped().as_str() {
+                    "json" => {
+                        // Load and parse as JSON module
+                        let json_content = std::fs::read_to_string(&path).map_err(|err| {
+                            JsNativeError::typ()
+                                .with_message(format!("could not open file `{short_path}`"))
+                                .with_cause(JsError::from_opaque(
+                                    js_string!(err.to_string()).into(),
+                                ))
+                        })?;
+                        let json_string = js_string!(json_content.as_str());
+                        Module::parse_json(json_string, &mut context.borrow_mut()).map_err(
+                            |err| {
+                                JsNativeError::syntax()
+                                    .with_message(format!(
+                                        "could not parse JSON module `{short_path}`"
+                                    ))
+                                    .with_cause(err)
+                            },
+                        )?
+                    }
+                    other => {
+                        // Unknown module type
+                        return Err(JsNativeError::typ()
+                            .with_message(format!(
+                                "unsupported module type `{other}` for module `{short_path}`"
+                            ))
+                            .into());
+                    }
+                }
+            } else {
+                // No type attribute, load as regular JavaScript module
+                let source = Source::from_filepath(&path).map_err(|err| {
+                    JsNativeError::typ()
+                        .with_message(format!("could not open file `{short_path}`"))
+                        .with_cause(JsError::from_opaque(js_string!(err.to_string()).into()))
+                })?;
+                Module::parse(source, None, &mut context.borrow_mut()).map_err(|err| {
+                    JsNativeError::syntax()
+                        .with_message(format!("could not parse module `{short_path}`"))
+                        .with_cause(err)
+                })?
+            };
+
+            self.insert_with_attributes(path, request.attributes(), module.clone());
             Ok(module)
         })();

diff --git a/core/engine/src/module/mod.rs b/core/engine/src/module/mod.rs
index af05f9fb..1ac498e2 100644
--- a/core/engine/src/module/mod.rs
+++ b/core/engine/src/module/mod.rs
@@ -29,6 +29,7 @@ use std::rc::Rc;

 use rustc_hash::FxHashSet;

+use boa_ast::declaration::ImportAttribute;
 use boa_engine::js_string;
 use boa_engine::property::PropertyKey;
 use boa_engine::value::TryFromJs;
@@ -36,11 +37,13 @@ use boa_gc::{Finalize, Gc, GcRefCell, Trace};
 use boa_interner::Interner;
 use boa_parser::source::ReadChar;
 use boa_parser::{Parser, Source};
+
 pub use loader::*;
 pub use namespace::ModuleNamespace;
 use source::SourceTextModule;
 pub use synthetic::{SyntheticModule, SyntheticModuleInitializer};

+use crate::bytecompiler::ToJsString;
 use crate::object::TypedJsFunction;
 use crate::spanned_source_text::SourceText;
 use crate::{
@@ -57,6 +60,82 @@ mod namespace;
 mod source;
 mod synthetic;

+/// A module request with optional import attributes.
+///
+/// Represents a module specifier and its associated import attributes.
+/// According to the [ECMAScript specification][spec], the module cache key
+/// should be (referrer, specifier, attributes).
+///
+/// [spec]: https://tc39.es/ecma262/#sec-modulerequest-record
+#[derive(Debug, Clone, PartialEq, Eq, Hash, Trace, Finalize)]
+pub struct ModuleRequest {
+    specifier: JsString,
+    attributes: Box<[(JsString, JsString)]>,
+}
+
+impl ModuleRequest {
+    /// Creates a new module request from a specifier and attributes.
+    #[must_use]
+    pub fn new(specifier: JsString, mut attributes: Box<[(JsString, JsString)]>) -> Self {
+        // Sort attributes by key to ensure canonical cache keys.
+        attributes.sort_unstable_by(|(k1, _), (k2, _)| k1.cmp(k2));
+        Self {
+            specifier,
+            attributes,
+        }
+    }
+
+    /// Creates a new module request from only a specifier with no attributes.
+    #[must_use]
+    pub fn from_specifier(specifier: JsString) -> Self {
+        Self {
+            specifier,
+            attributes: Box::new([]),
+        }
+    }
+
+    /// Creates a new module request from an AST specifier and attributes.
+    #[must_use]
+    pub(crate) fn from_ast(
+        specifier: JsString,
+        attributes: &[ImportAttribute],
+        interner: &Interner,
+    ) -> Self {
+        let attributes = attributes
+            .iter()
+            .map(|attr| {
+                (
+                    attr.key().to_js_string(interner),
+                    attr.value().to_js_string(interner),
+                )
+            })
+            .collect::<Vec<_>>()
+            .into_boxed_slice();
+        Self::new(specifier, attributes)
+    }
+
+    /// Gets the module specifier.
+    #[must_use]
+    pub fn specifier(&self) -> &JsString {
+        &self.specifier
+    }
+
+    /// Gets the import attributes as key-value pairs.
+    #[must_use]
+    pub fn attributes(&self) -> &[(JsString, JsString)] {
+        &self.attributes
+    }
+
+    /// Gets the value of a specific attribute by key.
+    #[must_use]
+    pub fn get_attribute(&self, key: &str) -> Option<&JsString> {
+        self.attributes
+            .iter()
+            .find(|(k, _)| k == key)
+            .map(|(_, v)| v)
+    }
+}
+
 /// ECMAScript's [**Abstract module record**][spec].
 ///
 /// [spec]: https://tc39.es/ecma262/#sec-abstract-module-records
@@ -845,3 +924,26 @@ fn can_throw_exception() {
         Some(&js_string!("from javascript").into())
     );
 }
+
+#[test]
+fn test_module_request_attribute_sorting() {
+    let request1 = ModuleRequest::new(
+        js_string!("specifier"),
+        Box::new([
+            (js_string!("key2"), js_string!("val2")),
+            (js_string!("key1"), js_string!("val1")),
+        ]),
+    );
+
+    let request2 = ModuleRequest::new(
+        js_string!("specifier"),
+        Box::new([
+            (js_string!("key1"), js_string!("val1")),
+            (js_string!("key2"), js_string!("val2")),
+        ]),
+    );
+
+    assert_eq!(request1, request2);
+    assert_eq!(request1.attributes()[0].0, js_string!("key1"));
+    assert_eq!(request1.attributes()[1].0, js_string!("key2"));
+}
diff --git a/core/engine/src/module/source.rs b/core/engine/src/module/source.rs
index 642c5145..af500813 100644
--- a/core/engine/src/module/source.rs
+++ b/core/engine/src/module/source.rs
@@ -220,7 +220,7 @@ impl std::fmt::Debug for SourceTextContext {
 #[derive(Trace, Finalize)]
 pub(crate) struct SourceTextModule {
     status: GcRefCell<ModuleStatus>,
-    loaded_modules: GcRefCell<FxHashMap<JsString, Module>>,
+    loaded_modules: GcRefCell<FxHashMap<super::ModuleRequest, Module>>,
     async_parent_modules: GcRefCell<Vec<Module>>,
     import_meta: GcRefCell<Option<JsObject>>,
     #[unsafe_ignore_trace]
@@ -241,14 +241,63 @@ impl std::fmt::Debug for SourceTextModule {
 #[derive(Debug)]
 struct ModuleCode {
     has_tla: bool,
-    requested_modules: IndexSet<JsString, BuildHasherDefault<FxHasher>>,
+    requested_modules: IndexSet<super::ModuleRequest, BuildHasherDefault<FxHasher>>,
     source: boa_ast::Module,
     source_text: SourceText,
     path: Option<PathBuf>,
     import_entries: Vec<ImportEntry>,
     local_export_entries: Vec<LocalExportEntry>,
     indirect_export_entries: Vec<IndirectExportEntry>,
-    star_export_entries: Vec<JsString>,
+    star_export_entries: Vec<super::ModuleRequest>,
+}
+
+struct ModuleRequestsVisitor<'a> {
+    interner: &'a Interner,
+    requests: IndexSet<super::ModuleRequest, BuildHasherDefault<FxHasher>>,
+}
+
+impl<'ast> boa_ast::visitor::Visitor<'ast> for ModuleRequestsVisitor<'_> {
+    type BreakTy = std::convert::Infallible;
+
+    fn visit_import_declaration(
+        &mut self,
+        node: &'ast boa_ast::declaration::ImportDeclaration,
+    ) -> std::ops::ControlFlow<Self::BreakTy> {
+        let specifier = node.specifier().sym().to_js_string(self.interner);
+        self.requests.insert(super::ModuleRequest::from_ast(
+            specifier,
+            node.attributes(),
+            self.interner,
+        ));
+        std::ops::ControlFlow::Continue(())
+    }
+
+    fn visit_export_declaration(
+        &mut self,
+        node: &'ast boa_ast::declaration::ExportDeclaration,
+    ) -> std::ops::ControlFlow<Self::BreakTy> {
+        if let boa_ast::declaration::ExportDeclaration::ReExport {
+            specifier,
+            attributes,
+            ..
+        } = node
+        {
+            let spec = specifier.sym().to_js_string(self.interner);
+            self.requests.insert(super::ModuleRequest::from_ast(
+                spec,
+                attributes,
+                self.interner,
+            ));
+        }
+        std::ops::ControlFlow::Continue(())
+    }
+
+    fn visit_statement_list_item(
+        &mut self,
+        _: &'ast boa_ast::StatementListItem,
+    ) -> std::ops::ControlFlow<Self::BreakTy> {
+        std::ops::ControlFlow::Continue(())
+    }
 }

 impl SourceTextModule {
@@ -264,12 +313,16 @@ impl SourceTextModule {
         path: Option<PathBuf>,
     ) -> Self {
         // 3. Let requestedModules be the ModuleRequests of body.
-        let requested_modules = code
-            .items()
-            .requests()
-            .iter()
-            .map(|name| name.to_js_string(interner))
-            .collect();
+        let requested_modules = {
+            use boa_ast::visitor::Visitor;
+
+            let mut visitor = ModuleRequestsVisitor {
+                interner,
+                requests: IndexSet::default(),
+            };
+            let _ = visitor.visit_module(&code);
+            visitor.requests
+        };
         // 4. Let importEntries be ImportEntries of body.
         let import_entries = code.items().import_entries();

@@ -290,10 +343,10 @@ impl SourceTextModule {
                 ExportEntry::Ordinary(entry) => {
                     // ii. Else,
                     //     1. Let ie be the element of importEntries whose [[LocalName]] is ee.[[LocalName]].
-                    if let Some((module, import)) =
+                    if let Some((module, import, attrs)) =
                         import_entries.iter().find_map(|ie| match ie.import_name() {
                             ImportName::Name(name) if ie.local_name() == entry.local_name() => {
-                                Some((ie.module_request(), name))
+                                Some((ie.module_request(), name, ie.attributes()))
                             }
                             _ => None,
                         })
@@ -307,6 +360,7 @@ impl SourceTextModule {
                             module,
                             ReExportImportName::Name(import),
                             entry.export_name(),
+                            attrs.to_vec().into_boxed_slice(),
                         ));
                     } else {
                         // i. If importedBoundNames does not contain ee.[[LocalName]], then
@@ -319,10 +373,18 @@ impl SourceTextModule {
                     }
                 }
                 // b. Else if ee.[[ImportName]] is all-but-default, then
-                ExportEntry::StarReExport { module_request } => {
+                ExportEntry::StarReExport {
+                    module_request,
+                    attributes,
+                } => {
                     // i. Assert: ee.[[ExportName]] is null.
                     // ii. Append ee to starExportEntries.
-                    star_export_entries.push(module_request.to_js_string(interner));
+                    let spec = module_request.to_js_string(interner);
+                    star_export_entries.push(super::ModuleRequest::from_ast(
+                        spec,
+                        &attributes,
+                        interner,
+                    ));
                 }
                 // c. Else,
                 //    i. Append ee to indirectExportEntries.
@@ -385,7 +447,7 @@ impl SourceTextModule {
         /// [finish]: https://tc39.es/ecma262/#sec-FinishLoadingImportedModule
         /// [continue]: https://tc39.es/ecma262/#sec-ContinueModuleLoading
         async fn finish_loading_imported_module(
-            specifier: JsString,
+            request: super::ModuleRequest,
             src: Module,
             state: Rc<GraphLoadingState>,
             context: &RefCell<&mut Context>,
@@ -393,7 +455,7 @@ impl SourceTextModule {
             let loader = context.borrow().module_loader();
             let fut = loader.load_imported_module(
                 Referrer::Module(src.clone()),
-                specifier.clone(),
+                request.clone(),
                 context,
             );
             let mut stack = [MaybeUninit::<u8>::uninit(); 16];
@@ -413,7 +475,7 @@ impl SourceTextModule {
                 //    i. Append the Record { [[Specifier]]: specifier, [[Module]]: result.[[Value]] } to referrer.[[LoadedModules]].
                 let mut loaded_modules = src.loaded_modules.borrow_mut();
                 let entry = loaded_modules
-                    .entry(specifier)
+                    .entry(request)
                     .or_insert_with(|| loaded.clone());

                 //    i. Assert: That Record's [[Module]] is result.[[Value]].
@@ -483,13 +545,12 @@ impl SourceTextModule {
                     //       1. Perform HostLoadImportedModule(module, required, state.[[HostDefined]], state).
                     //       2. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters
                     //          the graph loading process through ContinueModuleLoading.
-                    let name_specifier = required.clone();
+                    let request = required.clone();
                     let src = module_self.clone();
                     let state = state.clone();
                     let async_job = NativeAsyncJob::with_realm(
                         async move |context| {
-                            finish_loading_imported_module(name_specifier, src, state, context)
-                                .await?;
+                            finish_loading_imported_module(request, src, state, context).await?;
                             Ok(JsValue::undefined())
                         },
                         context.realm().clone(),
@@ -609,7 +670,11 @@ impl SourceTextModule {
             // a. If SameValue(exportName, e.[[ExportName]]) is true, then
             if export_name == &e.export_name().to_js_string(interner) {
                 // i. Let importedModule be GetImportedModule(module, e.[[ModuleRequest]]).
-                let module_request = e.module_request().to_js_string(interner);
+                let module_request = super::ModuleRequest::from_ast(
+                    e.module_request().to_js_string(interner),
+                    e.attributes(),
+                    interner,
+                );
                 let imported_module = self.loaded_modules.borrow()[&module_request].clone();
                 return match e.import_name() {
                     // ii. If e.[[ImportName]] is all, then
@@ -1522,7 +1587,11 @@ impl SourceTextModule {
             // 7. For each ImportEntry Record in of module.[[ImportEntries]], do
             for entry in &self.code.import_entries {
                 // a. Let importedModule be GetImportedModule(module, in.[[ModuleRequest]]).
-                let module_request = entry.module_request().to_js_string(compiler.interner());
+                let module_request = super::ModuleRequest::from_ast(
+                    entry.module_request().to_js_string(compiler.interner()),
+                    entry.attributes(),
+                    compiler.interner(),
+                );
                 let imported_module = self.loaded_modules.borrow()[&module_request].clone();

                 if let ImportName::Name(name) = entry.import_name() {
@@ -1854,7 +1923,7 @@ impl SourceTextModule {
     }

     /// Gets the loaded modules of this module.
-    pub(crate) fn loaded_modules(&self) -> &GcRefCell<FxHashMap<JsString, Module>> {
+    pub(crate) fn loaded_modules(&self) -> &GcRefCell<FxHashMap<super::ModuleRequest, Module>> {
         &self.loaded_modules
     }

diff --git a/core/engine/src/vm/code_block.rs b/core/engine/src/vm/code_block.rs
index c2f3625f..1e0377dd 100644
--- a/core/engine/src/vm/code_block.rs
+++ b/core/engine/src/vm/code_block.rs
@@ -756,11 +756,13 @@ impl CodeBlock {
             | Instruction::Pos { value }
             | Instruction::Neg { value }
             | Instruction::IsObject { value }
-            | Instruction::ImportCall { value }
             | Instruction::BindThisValue { value }
             | Instruction::BitNot { value } => {
                 format!("value:{value}")
             }
+            Instruction::ImportCall { specifier, options } => {
+                format!("specifier:{specifier}, options:{options}")
+            }
             Instruction::PushClassField {
                 object,
                 name_index,
diff --git a/core/engine/src/vm/opcode/call/mod.rs b/core/engine/src/vm/opcode/call/mod.rs
index 4db13ef0..e5cfd4df 100644
--- a/core/engine/src/vm/opcode/call/mod.rs
+++ b/core/engine/src/vm/opcode/call/mod.rs
@@ -258,6 +258,92 @@ impl Operation for CallSpread {
     const COST: u8 = 3;
 }

+/// Parses the import attributes from the options object.
+fn parse_import_attributes(
+    specifier: JsString,
+    options: &JsValue,
+    context: &mut Context,
+) -> JsResult<crate::module::ModuleRequest> {
+    // Taken from `EvaluateImportCall`
+    //
+    // <https://tc39.es/proposal-import-attributes/#sec-evaluate-import-call>
+
+    // 1. Let attributes be a new empty List.
+    // 2. If options is not undefined, then
+    if options.is_undefined() {
+        return Ok(crate::module::ModuleRequest::from_specifier(specifier));
+    }
+
+    // a. If Type(options) is not Object, throw a TypeError exception.
+    if let Some(options_obj) = options.as_object() {
+        // b. Let attributesObj be ? Get(options, "with").
+        let with_key = crate::js_string!("with");
+        let with_val = options_obj.get(with_key, context)?;
+
+        // c. If attributesObj is undefined, then
+        //     i. Set attributesObj to ? Get(options, "assert").
+        let (attributes_val, is_assert) = if with_val.is_undefined() {
+            let assert_key = crate::js_string!("assert");
+            let assert_val = options_obj.get(assert_key, context)?;
+            (assert_val, true)
+        } else {
+            (with_val, false)
+        };
+
+        // d. If attributesObj is not undefined, then
+        if attributes_val.is_undefined() {
+            Ok(crate::module::ModuleRequest::from_specifier(specifier))
+        // i. If Type(attributesObj) is not Object, throw a TypeError exception.
+        } else if let Some(attributes_obj) = attributes_val.as_object() {
+            // ii. Let entries be ? EnumerableOwnProperties(attributesObj, "key+value").
+            let keys = attributes_obj
+                .enumerable_own_property_names(crate::property::PropertyNameKind::Key, context)?;
+
+            // iii. For each entry in entries, do
+            let mut attributes = Vec::with_capacity(keys.len());
+            for key in keys {
+                // 1. Let key be entry.[[Key]].
+                if !key.is_string() {
+                    continue;
+                }
+                let key_str = key.as_string().expect("key must be string").clone();
+
+                // 2. Let value be entry.[[Value]].
+                let value = attributes_obj.get(key_str.clone(), context)?;
+
+                // 3. If Type(value) is not String, throw a TypeError exception.
+                if !value.is_string() {
+                    return Err(JsNativeError::typ()
+                        .with_message("import attribute value must be a string")
+                        .into());
+                }
+
+                let value_str = value.as_string().expect("value must be string").clone();
+
+                // 4. Append the Record { [[Key]]: key, [[Value]]: value } to attributes.
+                attributes.push((key_str, value_str));
+            }
+
+            // 3. Return the Record { [[Specifier]]: specifier, [[Attributes]]: attributes }.
+            Ok(crate::module::ModuleRequest::new(
+                specifier,
+                attributes.into_boxed_slice(),
+            ))
+        } else {
+            let msg = if is_assert {
+                "the 'assert' option must be an object"
+            } else {
+                "the 'with' option must be an object"
+            };
+            Err(JsNativeError::typ().with_message(msg).into())
+        }
+    } else {
+        Err(JsNativeError::typ()
+            .with_message("import options must be an object or undefined")
+            .into())
+    }
+}
+
 /// Loads the module of a dynamic import. This combines the operations:
 /// - [`HostLoadImportedModule(referrer, specifierString, empty, promiseCapability).`][load]
 /// - [`FinishLoadingImportedModule ( referrer, specifier, payload, result )`][finish]
@@ -268,12 +354,12 @@ impl Operation for CallSpread {
 /// [continue]: https://tc39.es/ecma262/#sec-ContinueDynamicImport
 async fn load_dyn_import(
     referrer: Referrer,
-    specifier: JsString,
+    request: crate::module::ModuleRequest,
     cap: PromiseCapability,
     context: &RefCell<&mut Context>,
 ) -> JsResult<()> {
     let loader = context.borrow().module_loader();
-    let fut = loader.load_imported_module(referrer.clone(), specifier.clone(), context);
+    let fut = loader.load_imported_module(referrer.clone(), request.clone(), context);
     let mut stack = [MaybeUninit::<u8>::uninit(); 16];
     let mut heap = Vec::<MaybeUninit<u8>>::new();
     let completion = fut.init2(&mut stack, &mut heap).await;
@@ -301,8 +387,8 @@ async fn load_dyn_import(

     // 1. If result is a normal completion, then
     match referrer {
-        Referrer::Module(module) => {
-            let ModuleKind::SourceText(src) = module.kind() else {
+        Referrer::Module(mod_ref) => {
+            let ModuleKind::SourceText(src) = mod_ref.kind() else {
                 panic!("referrer cannot be a synthetic module");
             };

@@ -312,7 +398,7 @@ async fn load_dyn_import(
             //     b. Else,
             //         i. Append the Record { [[Specifier]]: specifier, [[Module]]: result.[[Value]] } to referrer.[[LoadedModules]].
             let entry = loaded_modules
-                .entry(specifier)
+                .entry(request)
                 .or_insert_with(|| module.clone());

             //         i. Assert: That Record's [[Module]] is result.[[Value]].
@@ -323,14 +409,14 @@ async fn load_dyn_import(
         Referrer::Realm(realm) => {
             let mut loaded_modules = realm.loaded_modules().borrow_mut();
             let entry = loaded_modules
-                .entry(specifier)
+                .entry(request.specifier().clone())
                 .or_insert_with(|| module.clone());
             debug_assert_eq!(&module, entry);
         }
         Referrer::Script(script) => {
             let mut loaded_modules = script.loaded_modules().borrow_mut();
             let entry = loaded_modules
-                .entry(specifier)
+                .entry(request.specifier().clone())
                 .or_insert_with(|| module.clone());
             debug_assert_eq!(&module, entry);
         }
@@ -441,7 +527,10 @@ pub(crate) struct ImportCall;

 impl ImportCall {
     #[inline(always)]
-    pub(super) fn operation(value: VaryingOperand, context: &mut Context) -> JsResult<()> {
+    pub(super) fn operation(
+        (specifier_op, options_op): (VaryingOperand, VaryingOperand),
+        context: &mut Context,
+    ) -> JsResult<()> {
         // Import Calls
         // Runtime Semantics: Evaluation
         // https://tc39.es/ecma262/#sec-import-call-runtime-semantics-evaluation
@@ -454,7 +543,10 @@ impl ImportCall {

         // 3. Let argRef be ? Evaluation of AssignmentExpression.
         // 4. Let specifier be ? GetValue(argRef).
-        let arg = context.vm.get_register(value.into()).clone();
+        let arg = context.vm.get_register(specifier_op.into()).clone();
+
+        // Get options if provided
+        let options = context.vm.get_register(options_op.into()).clone();

         // 5. Let promiseCapability be ! NewPromiseCapability(%Promise%).
         let cap = PromiseCapability::new(
@@ -465,27 +557,39 @@ impl ImportCall {
         let promise = cap.promise().clone();

         // 6. Let specifierString be Completion(ToString(specifier)).
-        match arg.to_string(context) {
+        let specifier_str = match arg.to_string(context) {
+            Ok(s) => s,
             // 7. IfAbruptRejectPromise(specifierString, promiseCapability).
             Err(err) => {
                 let err = err.into_opaque(context)?;
                 cap.reject().call(&JsValue::undefined(), &[err], context)?;
+                context.vm.set_register(specifier_op.into(), promise.into());
+                return Ok(());
             }
-            // 8. Perform HostLoadImportedModule(referrer, specifierString, empty, promiseCapability).
-            Ok(specifier) => {
-                let job = NativeAsyncJob::with_realm(
-                    async move |context| {
-                        load_dyn_import(referrer, specifier, cap, context).await?;
-                        Ok(JsValue::undefined())
-                    },
-                    context.realm().clone(),
-                );
-                context.enqueue_job(job.into());
+        };
+
+        let request = match parse_import_attributes(specifier_str, &options, context) {
+            Ok(req) => req,
+            Err(err) => {
+                let err = err.into_opaque(context)?;
+                cap.reject().call(&JsValue::undefined(), &[err], context)?;
+                context.vm.set_register(specifier_op.into(), promise.into());
+                return Ok(());
             }
-        }
+        };
+
+        // 8. Perform HostLoadImportedModule(referrer, specifierString, empty, promiseCapability).
+        let job = NativeAsyncJob::with_realm(
+            async move |context| {
+                load_dyn_import(referrer, request, cap, context).await?;
+                Ok(JsValue::undefined())
+            },
+            context.realm().clone(),
+        );
+        context.enqueue_job(job.into());

         // 9. Return promiseCapability.[[Promise]].
-        context.vm.set_register(value.into(), promise.into());
+        context.vm.set_register(specifier_op.into(), promise.into());

         Ok(())
     }
diff --git a/core/engine/src/vm/opcode/mod.rs b/core/engine/src/vm/opcode/mod.rs
index 6cc94a89..84acc4d5 100644
--- a/core/engine/src/vm/opcode/mod.rs
+++ b/core/engine/src/vm/opcode/mod.rs
@@ -1701,9 +1701,9 @@ generate_opcodes! {
     /// Dynamically import a module.
     ///
     /// - Registers:
-    ///   - Input: value
-    ///   - Output: value
-    ImportCall { value: VaryingOperand },
+    ///   - Input: specifier, options
+    ///   - Output: specifier
+    ImportCall { specifier: VaryingOperand, options: VaryingOperand },

     /// Pop the two values of the stack, strict equal compares the two values,
     /// if true jumps to address, otherwise push the second pop'ed value.
diff --git a/core/engine/tests/module.rs b/core/engine/tests/module.rs
index 30be324d..6f5b3c53 100644
--- a/core/engine/tests/module.rs
+++ b/core/engine/tests/module.rs
@@ -14,10 +14,10 @@ fn test_json_module_from_str() {
         async fn load_imported_module(
             self: Rc<Self>,
             _referrer: Referrer,
-            specifier: JsString,
+            request: boa_engine::module::ModuleRequest,
             context: &RefCell<&mut Context>,
         ) -> JsResult<Module> {
-            assert_eq!(specifier.to_std_string_escaped(), "basic");
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
             let src = self.0.clone();

             Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
@@ -61,3 +61,465 @@ fn test_json_module_from_str() {
         json_string
     );
 }
+
+#[test]
+fn test_json_module_dynamic_import() {
+    struct TestModuleLoader(JsString);
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            request: boa_engine::module::ModuleRequest,
+            context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
+
+            // Verify attributes were passed correctly
+            let type_attr = request
+                .get_attribute("type")
+                .expect("should have type attribute");
+            assert_eq!(type_attr.to_std_string_escaped(), "json");
+
+            let src = self.0.clone();
+            Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
+        }
+    }
+
+    let json_content = js_string!(r#"{"key":"value","other":123}"#);
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader(json_content.clone())))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        export let p = import('basic', { with: { type: 'json' } });
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    match promise.state() {
+        PromiseState::Fulfilled(_) => {}
+        _ => panic!("Module evaluation failed"),
+    }
+
+    // Get the exported promise 'p'
+    let p = module
+        .namespace(&mut context)
+        .get(js_string!("p"), &mut context)
+        .unwrap();
+
+    let p_obj = p.as_promise().unwrap();
+    context.run_jobs().unwrap();
+
+    match p_obj.state() {
+        PromiseState::Fulfilled(module_ns) => {
+            let default_export = module_ns
+                .as_object()
+                .unwrap()
+                .get(js_string!("default"), &mut context)
+                .unwrap();
+
+            assert_eq!(
+                JsString::from(
+                    default_export
+                        .to_json(&mut context)
+                        .unwrap()
+                        .unwrap()
+                        .to_string()
+                ),
+                json_content
+            );
+        }
+        PromiseState::Rejected(e) => {
+            panic!(
+                "Dynamic import failed: {:?}",
+                e.to_string(&mut context).unwrap()
+            );
+        }
+        PromiseState::Pending => panic!("Dynamic import is still pending"),
+    }
+}
+
+#[test]
+fn test_json_module_static_import_with_attributes() {
+    struct TestModuleLoader(JsString);
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            request: boa_engine::module::ModuleRequest,
+            context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
+
+            let type_attr = request
+                .get_attribute("type")
+                .expect("should have type attribute");
+            assert_eq!(type_attr.to_std_string_escaped(), "json");
+
+            let src = self.0.clone();
+            Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
+        }
+    }
+
+    let json_string = js_string!(r#"{"static":"import"}"#);
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader(json_string.clone())))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        import json from 'basic' with { type: 'json' };
+        export let value = json;
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    assert_eq!(
+        promise.state(),
+        PromiseState::Fulfilled(boa_engine::JsValue::undefined())
+    );
+
+    let value = module
+        .namespace(&mut context)
+        .get(js_string!("value"), &mut context)
+        .unwrap();
+
+    assert_eq!(
+        JsString::from(value.to_json(&mut context).unwrap().unwrap().to_string()),
+        json_string
+    );
+}
+
+#[test]
+fn test_json_module_reexport_with_attributes() {
+    struct TestModuleLoader(JsString);
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            request: boa_engine::module::ModuleRequest,
+            context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
+
+            let type_attr = request
+                .get_attribute("type")
+                .expect("should have type attribute");
+            assert_eq!(type_attr.to_std_string_escaped(), "json");
+
+            let src = self.0.clone();
+            Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
+        }
+    }
+
+    let json_string = js_string!(r#"{"re":"export"}"#);
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader(json_string.clone())))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        export { default as json } from 'basic' with { type: 'json' };
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    assert_eq!(
+        promise.state(),
+        PromiseState::Fulfilled(boa_engine::JsValue::undefined())
+    );
+
+    let json = module
+        .namespace(&mut context)
+        .get(js_string!("json"), &mut context)
+        .unwrap();
+
+    assert_eq!(
+        JsString::from(json.to_json(&mut context).unwrap().unwrap().to_string()),
+        json_string
+    );
+}
+
+#[test]
+fn test_dynamic_import_invalid_options() {
+    struct TestModuleLoader;
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            _request: boa_engine::module::ModuleRequest,
+            _context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            panic!("Module loading should not be triggered for invalid options");
+        }
+    }
+
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        export let p = import('basic', 'invalid-option-string');
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    match promise.state() {
+        PromiseState::Fulfilled(_) => {}
+        _ => panic!("Module evaluation failed"),
+    }
+
+    // Get the exported promise 'p'
+    let p = module
+        .namespace(&mut context)
+        .get(js_string!("p"), &mut context)
+        .unwrap();
+
+    let p_obj = p.as_promise().unwrap();
+    context.run_jobs().unwrap();
+
+    match p_obj.state() {
+        PromiseState::Rejected(e) => {
+            let error = e.as_object().unwrap();
+            let name = error.get(js_string!("name"), &mut context).unwrap();
+            assert_eq!(name.as_string().unwrap(), js_string!("TypeError"));
+        }
+        state => panic!("Dynamic import should be rejected with TypeError, got {state:?}"),
+    }
+}
+
+#[test]
+fn test_dynamic_import_non_string_attribute_value() {
+    struct TestModuleLoader;
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            _request: boa_engine::module::ModuleRequest,
+            _context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            panic!("Module loading should not be triggered for invalid attribute values");
+        }
+    }
+
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        export let p = import('basic', { with: { type: 123 } });
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    match promise.state() {
+        PromiseState::Fulfilled(_) => {}
+        _ => panic!("Module evaluation failed"),
+    }
+
+    let p = module
+        .namespace(&mut context)
+        .get(js_string!("p"), &mut context)
+        .unwrap();
+
+    let p_obj = p.as_promise().unwrap();
+    context.run_jobs().unwrap();
+
+    match p_obj.state() {
+        PromiseState::Rejected(e) => {
+            let error = e.as_object().unwrap();
+            let name = error.get(js_string!("name"), &mut context).unwrap();
+            assert_eq!(name.as_string().unwrap(), js_string!("TypeError"));
+            let message = error.get(js_string!("message"), &mut context).unwrap();
+            assert_eq!(
+                message.as_string().unwrap(),
+                js_string!("import attribute value must be a string")
+            );
+        }
+        state => panic!("Dynamic import should be rejected with TypeError, got {state:?}"),
+    }
+}
+
+#[test]
+fn test_dynamic_import_symbol_key() {
+    struct TestModuleLoader(JsString);
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            request: boa_engine::module::ModuleRequest,
+            context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
+
+            // Verify attributes were passed correctly (symbol key should be ignored)
+            assert!(request.get_attribute("type").is_none());
+
+            let src = self.0.clone();
+            Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
+        }
+    }
+
+    let json_content = js_string!(r#"{"ignore":"symbol"}"#);
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader(json_content.clone())))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        let sym = Symbol('type');
+        export let p = import('basic', { with: { [sym]: 'json' } });
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    match promise.state() {
+        PromiseState::Fulfilled(_) => {}
+        _ => panic!("Module evaluation failed"),
+    }
+
+    let p = module
+        .namespace(&mut context)
+        .get(js_string!("p"), &mut context)
+        .unwrap();
+
+    let p_obj = p.as_promise().unwrap();
+    context.run_jobs().unwrap();
+
+    match p_obj.state() {
+        PromiseState::Fulfilled(module_ns) => {
+            let default_export = module_ns
+                .as_object()
+                .unwrap()
+                .get(js_string!("default"), &mut context)
+                .unwrap();
+
+            assert_eq!(
+                JsString::from(
+                    default_export
+                        .to_json(&mut context)
+                        .unwrap()
+                        .unwrap()
+                        .to_string()
+                ),
+                json_content
+            );
+        }
+        PromiseState::Rejected(e) => {
+            panic!(
+                "Dynamic import failed: {:?}",
+                e.to_string(&mut context).unwrap()
+            );
+        }
+        PromiseState::Pending => panic!("Dynamic import is still pending"),
+    }
+}
+
+#[test]
+fn test_json_module_dynamic_import_assert() {
+    struct TestModuleLoader(JsString);
+    impl ModuleLoader for TestModuleLoader {
+        async fn load_imported_module(
+            self: Rc<Self>,
+            _referrer: Referrer,
+            request: boa_engine::module::ModuleRequest,
+            context: &RefCell<&mut Context>,
+        ) -> JsResult<Module> {
+            assert_eq!(request.specifier().to_std_string_escaped(), "basic");
+
+            // Verify attributes were passed correctly
+            let type_attr = request
+                .get_attribute("type")
+                .expect("should have type attribute");
+            assert_eq!(type_attr.to_std_string_escaped(), "json");
+
+            let src = self.0.clone();
+            Ok(Module::parse_json(src, &mut context.borrow_mut()).unwrap())
+        }
+    }
+
+    let json_content = js_string!(r#"{"assert":true,"key":"value"}"#);
+    let mut context = Context::builder()
+        .module_loader(Rc::new(TestModuleLoader(json_content.clone())))
+        .build()
+        .unwrap();
+
+    let source = Source::from_bytes(
+        b"
+        export let p = import('basic', { assert: { type: 'json' } });
+    ",
+    );
+
+    let module = Module::parse(source, None, &mut context).unwrap();
+    let promise = module.load_link_evaluate(&mut context);
+    context.run_jobs().unwrap();
+
+    match promise.state() {
+        PromiseState::Fulfilled(_) => {}
+        _ => panic!("Module evaluation failed"),
+    }
+
+    // Get the exported promise 'p'
+    let p = module
+        .namespace(&mut context)
+        .get(js_string!("p"), &mut context)
+        .unwrap();
+
+    let p_obj = p.as_promise().unwrap();
+    context.run_jobs().unwrap();
+
+    match p_obj.state() {
+        PromiseState::Fulfilled(module_ns) => {
+            let default_export = module_ns
+                .as_object()
+                .unwrap()
+                .get(js_string!("default"), &mut context)
+                .unwrap();
+
+            assert_eq!(
+                JsString::from(
+                    default_export
+                        .to_json(&mut context)
+                        .unwrap()
+                        .unwrap()
+                        .to_string()
+                ),
+                json_content
+            );
+        }
+        PromiseState::Rejected(e) => {
+            panic!(
+                "Dynamic import failed: {:?}",
+                e.to_string(&mut context).unwrap()
+            );
+        }
+        PromiseState::Pending => panic!("Dynamic import is still pending"),
+    }
+}
diff --git a/core/parser/src/parser/expression/left_hand_side/mod.rs b/core/parser/src/parser/expression/left_hand_side/mod.rs
index 4b6f5103..9554a76d 100644
--- a/core/parser/src/parser/expression/left_hand_side/mod.rs
+++ b/core/parser/src/parser/expression/left_hand_side/mod.rs
@@ -126,9 +126,33 @@ where
                 // `(`
                 cursor.advance(interner);

-                let arg = AssignmentExpression::new(true, self.allow_yield, self.allow_await)
+                let specifier = AssignmentExpression::new(true, self.allow_yield, self.allow_await)
                     .parse(cursor, interner)?;

+                let options =
+                    if cursor
+                        .next_if(TokenKind::Punctuator(Punctuator::Comma), interner)?
+                        .is_some()
+                    {
+                        if cursor.peek(0, interner)?.is_some_and(|t| {
+                            t.kind() == &TokenKind::Punctuator(Punctuator::CloseParen)
+                        }) {
+                            None
+                        } else {
+                            let opts =
+                                AssignmentExpression::new(true, self.allow_yield, self.allow_await)
+                                    .parse(cursor, interner)?;
+                            if cursor.peek(0, interner)?.is_some_and(|t| {
+                                t.kind() == &TokenKind::Punctuator(Punctuator::Comma)
+                            }) {
+                                cursor.advance(interner);
+                            }
+                            Some(opts)
+                        }
+                    } else {
+                        None
+                    };
+
                 let end = cursor
                     .expect(
                         TokenKind::Punctuator(Punctuator::CloseParen),
@@ -141,7 +165,7 @@ where
                 CallExpressionTail::new(
                     self.allow_yield,
                     self.allow_await,
-                    ImportCall::new(arg, Span::new(start, end)).into(),
+                    ImportCall::new(specifier, options, Span::new(start, end)).into(),
                 )
                 .parse(cursor, interner)?
                 .into()
diff --git a/core/parser/src/parser/statement/declaration/export.rs b/core/parser/src/parser/statement/declaration/export.rs
index cb2b3ff4..78b8d8f2 100644
--- a/core/parser/src/parser/statement/declaration/export.rs
+++ b/core/parser/src/parser/statement/declaration/export.rs
@@ -26,7 +26,7 @@ use boa_ast::{
 use boa_interner::{Interner, Sym};

 use super::{
-    Declaration, FromClause, FunctionDeclaration,
+    Declaration, FromClause, FunctionDeclaration, WithClause,
     hoistable::{AsyncFunctionDeclaration, AsyncGeneratorDeclaration, GeneratorDeclaration},
 };

@@ -57,7 +57,7 @@ where

                 let next = cursor.peek(0, interner).or_abrupt()?;

-                let export = match next.kind() {
+                let (kind, specifier) = match next.kind() {
                     TokenKind::IdentifierName((Sym::AS, _)) => {
                         cursor.advance(interner);
                         let tok = cursor.next(interner).or_abrupt()?;
@@ -79,19 +79,13 @@ where
                         let specifier =
                             FromClause::new("export declaration").parse(cursor, interner)?;

-                        AstExportDeclaration::ReExport {
-                            kind: ReExportKind::Namespaced { name: Some(alias) },
-                            specifier,
-                        }
+                        (ReExportKind::Namespaced { name: Some(alias) }, specifier)
                     }
                     TokenKind::IdentifierName((Sym::FROM, _)) => {
                         let specifier =
                             FromClause::new("export declaration").parse(cursor, interner)?;

-                        AstExportDeclaration::ReExport {
-                            kind: ReExportKind::Namespaced { name: None },
-                            specifier,
-                        }
+                        (ReExportKind::Namespaced { name: None }, specifier)
                     }
                     _ => {
                         return Err(Error::expected(
@@ -103,9 +97,14 @@ where
                     }
                 };

+                let attributes = WithClause::new("export declaration").parse(cursor, interner)?;
                 cursor.expect_semicolon("star re-export", interner)?;

-                export
+                AstExportDeclaration::ReExport {
+                    kind,
+                    specifier,
+                    attributes,
+                }
             }
             TokenKind::Punctuator(Punctuator::OpenBlock) => {
                 let names = NamedExports.parse(cursor, interner)?;
@@ -118,12 +117,15 @@ where
                 ) {
                     let specifier =
                         FromClause::new("export declaration").parse(cursor, interner)?;
+                    let attributes =
+                        WithClause::new("export declaration").parse(cursor, interner)?;

                     cursor.expect_semicolon("named re-exports", interner)?;

                     AstExportDeclaration::ReExport {
                         kind: ReExportKind::Named { names },
                         specifier,
+                        attributes,
                     }
                 } else {
                     cursor.expect_semicolon("named exports", interner)?;
diff --git a/core/parser/src/parser/statement/declaration/import.rs b/core/parser/src/parser/statement/declaration/import.rs
index 03553005..5ee13a7d 100644
--- a/core/parser/src/parser/statement/declaration/import.rs
+++ b/core/parser/src/parser/statement/declaration/import.rs
@@ -14,14 +14,17 @@ use crate::{
     parser::{
         Error, OrAbrupt, ParseResult, TokenParser,
         cursor::Cursor,
-        statement::{BindingIdentifier, declaration::FromClause},
+        statement::{
+            BindingIdentifier,
+            declaration::{FromClause, WithClause},
+        },
     },
     source::ReadChar,
 };
 use boa_ast::{
     Keyword, Punctuator, Spanned,
     declaration::{
-        ImportDeclaration as AstImportDeclaration, ImportKind,
+        ImportAttribute, ImportDeclaration as AstImportDeclaration, ImportKind,
         ImportSpecifier as AstImportSpecifier, ModuleSpecifier,
     },
     expression::Identifier,
@@ -84,12 +87,16 @@ where
                 let module_identifier = *module_identifier;

                 cursor.advance(interner);
+
+                let attributes = WithClause::new("import declaration").parse(cursor, interner)?;
+
                 cursor.expect_semicolon("import declaration", interner)?;

                 return Ok(AstImportDeclaration::new(
                     None,
                     ImportKind::DefaultOrUnnamed,
                     ModuleSpecifier::new(module_identifier),
+                    attributes,
                 ));
             }
             TokenKind::Punctuator(Punctuator::OpenBlock) => {
@@ -152,8 +159,11 @@ where
         };

         let module_identifier = FromClause::new("import declaration").parse(cursor, interner)?;
+        let attributes = WithClause::new("import declaration").parse(cursor, interner)?;

-        Ok(import_clause.with_specifier(module_identifier))
+        cursor.expect_semicolon("import declaration", interner)?;
+
+        Ok(import_clause.with_specifier_and_attributes(module_identifier, attributes))
     }
 }

@@ -257,17 +267,33 @@ enum ImportClause {

 impl ImportClause {
     #[inline]
-    #[allow(clippy::missing_const_for_fn)]
-    fn with_specifier(self, specifier: ModuleSpecifier) -> AstImportDeclaration {
+    fn with_specifier_and_attributes(
+        self,
+        specifier: ModuleSpecifier,
+        attributes: Box<[ImportAttribute]>,
+    ) -> AstImportDeclaration {
         match self {
-            Self::Namespace(default, binding) => {
-                AstImportDeclaration::new(default, ImportKind::Namespaced { binding }, specifier)
-            }
+            Self::Namespace(default, binding) => AstImportDeclaration::new(
+                default,
+                ImportKind::Namespaced { binding },
+                specifier,
+                attributes,
+            ),
             Self::ImportList(default, names) => {
                 if names.is_empty() {
-                    AstImportDeclaration::new(default, ImportKind::DefaultOrUnnamed, specifier)
+                    AstImportDeclaration::new(
+                        default,
+                        ImportKind::DefaultOrUnnamed,
+                        specifier,
+                        attributes,
+                    )
                 } else {
-                    AstImportDeclaration::new(default, ImportKind::Named { names }, specifier)
+                    AstImportDeclaration::new(
+                        default,
+                        ImportKind::Named { names },
+                        specifier,
+                        attributes,
+                    )
                 }
             }
         }
diff --git a/core/parser/src/parser/statement/declaration/mod.rs b/core/parser/src/parser/statement/declaration/mod.rs
index 792c285c..65ad81e3 100644
--- a/core/parser/src/parser/statement/declaration/mod.rs
+++ b/core/parser/src/parser/statement/declaration/mod.rs
@@ -28,7 +28,7 @@ use crate::{
     parser::{AllowAwait, AllowYield, Cursor, OrAbrupt, ParseResult, TokenParser},
     source::ReadChar,
 };
-use boa_ast::{self as ast, Keyword, Spanned};
+use boa_ast::{self as ast, Keyword, Punctuator, Spanned, declaration::ImportAttribute};
 use boa_interner::{Interner, Sym};

 /// Parses a declaration.
@@ -135,3 +135,130 @@ where
         Ok((*from).into())
     }
 }
+
+/// Parses an optional `with` clause for import attributes.
+///
+/// More information:
+///  - [ECMAScript specification][spec]
+///
+/// [spec]: https://tc39.es/ecma262/#sec-imports
+#[derive(Debug, Clone, Copy)]
+pub(in crate::parser) struct WithClause {
+    context: &'static str,
+}
+
+impl WithClause {
+    /// Creates a new `with` clause parser.
+    #[inline]
+    pub(in crate::parser) const fn new(context: &'static str) -> Self {
+        Self { context }
+    }
+}
+
+impl<R> TokenParser<R> for WithClause
+where
+    R: ReadChar,
+{
+    type Output = Box<[ImportAttribute]>;
+
+    fn parse(self, cursor: &mut Cursor<R>, interner: &mut Interner) -> ParseResult<Self::Output> {
+        let Some(tok) = cursor.peek(0, interner)? else {
+            return Ok(Box::default());
+        };
+
+        let is_with = matches!(tok.kind(), TokenKind::Keyword((Keyword::With, _)));
+        let is_assert = if is_with {
+            false
+        } else {
+            matches!(tok.kind(), TokenKind::IdentifierName((sym, _)) if interner.resolve_expect(*sym).utf8().is_some_and(|s| s == "assert"))
+        };
+
+        // Only treat `with` / `assert` as part of a with-clause if it is
+        // followed by an opening `{`. This avoids mis-parsing code like:
+        //
+        // import x from "mod";
+        // assert.sameValue(x, 1);
+        //
+        // where the `assert` identifier on the next line should not be parsed
+        // as an import attributes clause.
+        if !is_with && !is_assert {
+            return Ok(Box::default());
+        }
+
+        let Some(next_tok) = cursor.peek(1, interner)? else {
+            return Ok(Box::default());
+        };
+
+        if next_tok.kind() != &TokenKind::Punctuator(Punctuator::OpenBlock) {
+            return Ok(Box::default());
+        }
+
+        cursor.advance(interner);
+
+        cursor.expect(Punctuator::OpenBlock, self.context, interner)?;
+
+        let mut attributes = Vec::new();
+
+        loop {
+            let tok = cursor.peek(0, interner).or_abrupt()?;
+
+            if tok.kind() == &TokenKind::Punctuator(Punctuator::CloseBlock) {
+                break;
+            }
+
+            let key_tok = cursor.next(interner).or_abrupt()?;
+            let key = match key_tok.kind() {
+                TokenKind::IdentifierName((name, _)) | TokenKind::StringLiteral((name, _)) => *name,
+                TokenKind::Keyword((kw, _)) => kw.to_sym(),
+                _ => {
+                    return Err(Error::expected(
+                        ["identifier".to_owned(), "string literal".to_owned()],
+                        key_tok.to_string(interner),
+                        key_tok.span(),
+                        self.context,
+                    ));
+                }
+            };
+
+            cursor.expect(Punctuator::Colon, self.context, interner)?;
+
+            let value_tok = cursor.next(interner).or_abrupt()?;
+            let TokenKind::StringLiteral((value, _)) = value_tok.kind() else {
+                return Err(Error::expected(
+                    ["string literal".to_owned()],
+                    value_tok.to_string(interner),
+                    value_tok.span(),
+                    self.context,
+                ));
+            };
+
+            if attributes
+                .iter()
+                .any(|attr: &ImportAttribute| attr.key() == key)
+            {
+                return Err(Error::general(
+                    "duplicate attribute key in import attributes",
+                    key_tok.span().start(),
+                ));
+            }
+
+            attributes.push(ImportAttribute::new(key, *value));
+
+            let tok = cursor.peek(0, interner).or_abrupt()?;
+            if tok.kind() == &TokenKind::Punctuator(Punctuator::Comma) {
+                cursor.advance(interner);
+            } else if tok.kind() != &TokenKind::Punctuator(Punctuator::CloseBlock) {
+                return Err(Error::expected(
+                    [",".to_owned(), "}".to_owned()],
+                    tok.to_string(interner),
+                    tok.span(),
+                    self.context,
+                ));
+            }
+        }
+
+        cursor.expect(Punctuator::CloseBlock, self.context, interner)?;
+
+        Ok(attributes.into_boxed_slice())
+    }
+}
diff --git a/core/parser/src/parser/statement/declaration/tests.rs b/core/parser/src/parser/statement/declaration/tests.rs
index 807ad93c..945d4aee 100644
--- a/core/parser/src/parser/statement/declaration/tests.rs
+++ b/core/parser/src/parser/statement/declaration/tests.rs
@@ -1,8 +1,10 @@
 use crate::parser::tests::{check_invalid_script, check_module_parser, check_script_parser};
+use crate::{Parser, Source};
 use boa_ast::{
     Declaration, ModuleItem, Span, Statement,
     declaration::{
-        ExportDeclaration, ExportSpecifier, LexicalDeclaration, VarDeclaration, Variable,
+        ExportDeclaration, ExportSpecifier, ImportAttribute, ImportDeclaration, ImportKind,
+        LexicalDeclaration, ModuleSpecifier, ReExportKind, VarDeclaration, Variable,
     },
     expression::{
         Identifier,
@@ -486,3 +488,194 @@ fn module_export_reserved() {
         interner,
     );
 }
+
+/// Checks import declaration with a single attribute.
+#[test]
+fn import_with_single_attribute() {
+    let interner = &mut Interner::default();
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+    let foo_json = interner.get_or_intern_static("./foo.json", utf16!("./foo.json"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+
+    check_module_parser(
+        r#"import json from "./foo.json" with { type: "json" };"#,
+        vec![ModuleItem::ImportDeclaration(ImportDeclaration::new(
+            Some(Identifier::new(json, Span::new((1, 8), (1, 12)))),
+            ImportKind::DefaultOrUnnamed,
+            ModuleSpecifier::new(foo_json),
+            vec![ImportAttribute::new(type_sym, json)].into(),
+        ))],
+        interner,
+    );
+}
+
+/// Checks import declaration with multiple attributes.
+#[test]
+fn import_with_multiple_attributes() {
+    let interner = &mut Interner::default();
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+    let foo_json = interner.get_or_intern_static("./foo.json", utf16!("./foo.json"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+    let integrity = interner.get_or_intern_static("integrity", utf16!("integrity"));
+    let hash = interner.get_or_intern_static("sha384-abc123", utf16!("sha384-abc123"));
+
+    check_module_parser(
+        r#"import json from "./foo.json" with { type: "json", integrity: "sha384-abc123" };"#,
+        vec![ModuleItem::ImportDeclaration(ImportDeclaration::new(
+            Some(Identifier::new(json, Span::new((1, 8), (1, 12)))),
+            ImportKind::DefaultOrUnnamed,
+            ModuleSpecifier::new(foo_json),
+            vec![
+                ImportAttribute::new(type_sym, json),
+                ImportAttribute::new(integrity, hash),
+            ]
+            .into(),
+        ))],
+        interner,
+    );
+}
+
+/// Checks import declaration with trailing comma in attributes.
+#[test]
+fn import_with_trailing_comma_attribute() {
+    let interner = &mut Interner::default();
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+    let foo_json = interner.get_or_intern_static("./foo.json", utf16!("./foo.json"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+
+    check_module_parser(
+        r#"import json from "./foo.json" with { type: "json", };"#,
+        vec![ModuleItem::ImportDeclaration(ImportDeclaration::new(
+            Some(Identifier::new(json, Span::new((1, 8), (1, 12)))),
+            ImportKind::DefaultOrUnnamed,
+            ModuleSpecifier::new(foo_json),
+            vec![ImportAttribute::new(type_sym, json)].into(),
+        ))],
+        interner,
+    );
+}
+
+/// Checks re-export with attributes.
+#[test]
+fn reexport_with_attributes() {
+    let interner = &mut Interner::default();
+    let foo_js = interner.get_or_intern_static("./foo.js", utf16!("./foo.js"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+
+    check_module_parser(
+        r#"export * from "./foo.js" with { type: "json" };"#,
+        vec![ModuleItem::ExportDeclaration(Box::new(
+            ExportDeclaration::ReExport {
+                kind: ReExportKind::Namespaced { name: None },
+                specifier: ModuleSpecifier::new(foo_js),
+                attributes: vec![ImportAttribute::new(type_sym, json)].into(),
+            },
+        ))],
+        interner,
+    );
+}
+
+/// Checks import attributes with string literal key.
+#[test]
+fn import_with_string_literal_key() {
+    let interner = &mut Interner::default();
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+    let foo_json = interner.get_or_intern_static("./foo.json", utf16!("./foo.json"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+
+    check_module_parser(
+        r#"import json from "./foo.json" with { "type": "json" };"#,
+        vec![ModuleItem::ImportDeclaration(ImportDeclaration::new(
+            Some(Identifier::new(json, Span::new((1, 8), (1, 12)))),
+            ImportKind::DefaultOrUnnamed,
+            ModuleSpecifier::new(foo_json),
+            vec![ImportAttribute::new(type_sym, json)].into(),
+        ))],
+        interner,
+    );
+}
+
+/// Checks that duplicate attribute keys are rejected.
+#[test]
+fn import_duplicate_attribute_key() {
+    assert!(
+        Parser::new(Source::from_bytes(
+            r#"import json from "./foo.json" with { type: "json", type: "css" };"#
+        ))
+        .parse_module(
+            &boa_ast::scope::Scope::new_global(),
+            &mut Interner::default()
+        )
+        .is_err()
+    );
+}
+
+/// Checks that non-string attribute values are rejected.
+#[test]
+fn import_non_string_attribute_value() {
+    let scope = boa_ast::scope::Scope::new_global();
+
+    assert!(
+        Parser::new(Source::from_bytes(
+            r#"import json from "./foo.json" with { type: json };"#
+        ))
+        .parse_module(&scope, &mut Interner::default())
+        .is_err()
+    );
+    assert!(
+        Parser::new(Source::from_bytes(
+            r#"import json from "./foo.json" with { type: 123 };"#
+        ))
+        .parse_module(&scope, &mut Interner::default())
+        .is_err()
+    );
+    assert!(
+        Parser::new(Source::from_bytes(
+            r#"import json from "./foo.json" with { type: true };"#
+        ))
+        .parse_module(&scope, &mut Interner::default())
+        .is_err()
+    );
+}
+
+/// Checks import declaration with assert keyword.
+#[test]
+fn import_with_assert_keyword() {
+    let interner = &mut Interner::default();
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+    let foo_json = interner.get_or_intern_static("./foo.json", utf16!("./foo.json"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+
+    check_module_parser(
+        r#"import json from "./foo.json" assert { type: "json" };"#,
+        vec![ModuleItem::ImportDeclaration(ImportDeclaration::new(
+            Some(Identifier::new(json, Span::new((1, 8), (1, 12)))),
+            ImportKind::DefaultOrUnnamed,
+            ModuleSpecifier::new(foo_json),
+            vec![ImportAttribute::new(type_sym, json)].into(),
+        ))],
+        interner,
+    );
+}
+
+/// Checks re-export with assert keyword.
+#[test]
+fn reexport_with_assert_keyword() {
+    let interner = &mut Interner::default();
+    let foo_js = interner.get_or_intern_static("./foo.js", utf16!("./foo.js"));
+    let type_sym = interner.get_or_intern_static("type", utf16!("type"));
+    let json = interner.get_or_intern_static("json", utf16!("json"));
+
+    check_module_parser(
+        r#"export * from "./foo.js" assert { type: "json" };"#,
+        vec![ModuleItem::ExportDeclaration(Box::new(
+            ExportDeclaration::ReExport {
+                kind: ReExportKind::Namespaced { name: None },
+                specifier: ModuleSpecifier::new(foo_js),
+                attributes: vec![ImportAttribute::new(type_sym, json)].into(),
+            },
+        ))],
+        interner,
+    );
+}
diff --git a/examples/src/bin/module_fetch_async.rs b/examples/src/bin/module_fetch_async.rs
index bb578ced..d0be4196 100644
--- a/examples/src/bin/module_fetch_async.rs
+++ b/examples/src/bin/module_fetch_async.rs
@@ -1,11 +1,11 @@
 use std::{cell::RefCell, collections::VecDeque, rc::Rc};

 use boa_engine::{
-    Context, JsNativeError, JsResult, JsString, JsValue, Module,
+    Context, JsNativeError, JsResult, JsValue, Module,
     builtins::promise::PromiseState,
     job::{Job, JobExecutor, NativeAsyncJob, PromiseJob},
     js_string,
-    module::ModuleLoader,
+    module::{ModuleLoader, ModuleRequest},
 };
 use boa_parser::Source;
 use futures_concurrency::future::FutureGroup;
@@ -22,10 +22,10 @@ impl ModuleLoader for HttpModuleLoader {
     async fn load_imported_module(
         self: Rc<Self>,
         _referrer: boa_engine::module::Referrer,
-        specifier: JsString,
+        request: ModuleRequest,
         context: &RefCell<&mut Context>,
     ) -> JsResult<Module> {
-        let url = specifier.to_std_string_escaped();
+        let url = request.specifier().to_std_string_escaped();

         // Adding some prints to show the non-deterministic nature of the async fetches.
         // Try to run the example several times to see how sometimes the fetches start in order
diff --git a/test262_config.toml b/test262_config.toml
index d2a7cffc..3567be58 100644
--- a/test262_config.toml
+++ b/test262_config.toml
@@ -13,8 +13,6 @@ features = [
     "Intl.DisplayNames",
     "Intl.RelativeTimeFormat",
     "Intl-enumeration",
-    "import-attributes",
-    "json-modules",
     "Intl.DurationFormat",
     "regexp-duplicate-named-groups",
     "iterator-helpers",
