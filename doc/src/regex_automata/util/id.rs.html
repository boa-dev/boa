<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/regex-automata-0.2.0/src/util/id.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>id.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
Type definitions for identifier types.

A [`StateID`] represents the possible set of identifiers used in regex engine
implementations in this crate. For example, they are used to identify both NFA
and DFA states.

A [`PatternID`] represents the possible set of identifiers for patterns. All
regex engine implementations in this crate support searching for multiple
patterns simultaneously. A `PatternID` is how each pattern is uniquely
identified for a particular instance of a regex engine. Namely, a pattern is
assigned an auto-incrementing integer, starting at `0`, based on the order of
patterns supplied during the construction of the regex engine.

These identifier types represent a way for this crate to make correctness
guarantees around the possible set of values that a `StateID` or a `PatternID`
might represent. Similarly, they also provide a way of constraining the size of
these identifiers to reduce space usage while still guaranteeing that all such
identifiers are repsentable by a `usize` for the current target.

Moreover, the identifier types clamp the range of permissible values to a range
that is typically smaller than its internal representation. (With the maximum
value being, e.g., `StateID::MAX`.) Users of these types may not rely this
clamping for the purpose of memory safety. Users may, however, rely on these
invariants to avoid panics or other types of logic bugs.
*/</span>

<span class="comment">// Continuing from the above comment about correctness guarantees, an example</span>
<span class="comment">// of a way in which we use the guarantees on these types is delta encoding.</span>
<span class="comment">// Namely, we require that IDs can be at most 2^31 - 2, which means the</span>
<span class="comment">// difference between any two IDs is always representable as an i32.</span>

<span class="kw">use</span> <span class="ident">core</span>::{
    <span class="ident">convert</span>::{<span class="ident">Infallible</span>, <span class="ident">TryFrom</span>},
    <span class="ident">mem</span>, <span class="ident">ops</span>,
};

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">alloc::vec::Vec</span>;

<span class="doccomment">/// An identifier for a regex pattern.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The identifier for a pattern corresponds to its relative position among</span>
<span class="doccomment">/// other patterns in a single finite state machine. Namely, when building</span>
<span class="doccomment">/// a multi-pattern regex engine, one must supply a sequence of patterns to</span>
<span class="doccomment">/// match. The position (starting at 0) of each pattern in that sequence</span>
<span class="doccomment">/// represents its identifier. This identifier is in turn used to identify and</span>
<span class="doccomment">/// report matches of that pattern in various APIs.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A pattern ID is guaranteed to be representable by a `usize`. Similarly,</span>
<span class="doccomment">/// the number of patterns in any regex engine in this crate is guaranteed to</span>
<span class="doccomment">/// be representable by a `usize`. This applies to regex engines that have</span>
<span class="doccomment">/// been deserialized; a deserialization error will be returned if it contains</span>
<span class="doccomment">/// pattern IDs that violate these requirements in your current environment.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For extra convenience in some cases, this type also guarantees that all</span>
<span class="doccomment">/// IDs can fit into an `i32` and an `isize` without overflowing.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Representation</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This type is always represented internally by a `u32` and is marked as</span>
<span class="doccomment">/// `repr(transparent)`. Thus, this type always has the same representation as</span>
<span class="doccomment">/// a `u32`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Indexing</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For convenience, callers may use a `PatternID` to index slices.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Safety</span>
<span class="doccomment">///</span>
<span class="doccomment">/// While a `PatternID` is meant to guarantee that its value fits into `usize`</span>
<span class="doccomment">/// (while using a possibly smaller representation than `usize` on some</span>
<span class="doccomment">/// targets), callers must not rely on this property for safety. Callers may</span>
<span class="doccomment">/// choose to rely on this property for correctness however.</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(
    <span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>, <span class="ident">Ord</span>,
)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PatternID</span>(<span class="ident">u32</span>);

<span class="kw">impl</span> <span class="ident">PatternID</span> {
    <span class="doccomment">/// The maximum pattern ID value, represented as a `usize`.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;32&quot;</span>, <span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>))]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX</span>: <span class="ident">PatternID</span> <span class="op">=</span>
        <span class="ident">PatternID::new_unchecked</span>(<span class="ident">core::i32::MAX</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">-</span> <span class="number">1</span>);

    <span class="doccomment">/// The maximum pattern ID value, represented as a `usize`.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;16&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX</span>: <span class="ident">PatternID</span> <span class="op">=</span> <span class="ident">PatternID::new_unchecked</span>(<span class="ident">core::isize::MAX</span> <span class="op">-</span> <span class="number">1</span>);

    <span class="doccomment">/// The total number of patterns that are allowed in any single regex</span>
    <span class="doccomment">/// engine.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">LIMIT</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">PatternID::MAX</span>.<span class="ident">as_usize</span>() <span class="op">+</span> <span class="number">1</span>;

    <span class="doccomment">/// The zero pattern ID value.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ZERO</span>: <span class="ident">PatternID</span> <span class="op">=</span> <span class="ident">PatternID::new_unchecked</span>(<span class="number">0</span>);

    <span class="doccomment">/// The number of bytes that a single `PatternID` uses in memory.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SIZE</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">core::mem::size_of</span>::<span class="op">&lt;</span><span class="ident">PatternID</span><span class="op">&gt;</span>();

    <span class="doccomment">/// Create a new pattern ID.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the given identifier exceeds [`PatternID::MAX`], then this returns</span>
    <span class="doccomment">/// an error.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">PatternID</span>, <span class="ident">PatternIDError</span><span class="op">&gt;</span> {
        <span class="ident">PatternID::try_from</span>(<span class="ident">id</span>)
    }

    <span class="doccomment">/// Create a new pattern ID without checking whether the given value</span>
    <span class="doccomment">/// exceeds [`PatternID::MAX`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// While this is unchecked, providing an incorrect value must never</span>
    <span class="doccomment">/// sacrifice memory safety, as documented above.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="ident">PatternID</span> {
        <span class="ident">PatternID</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">u32</span>)
    }

    <span class="doccomment">/// Like [`PatternID::new`], but panics if the given ID is not valid.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">must</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="ident">PatternID</span> {
        <span class="ident">PatternID::new</span>(<span class="ident">id</span>).<span class="ident">unwrap</span>()
    }

    <span class="doccomment">/// Return this pattern ID as a `usize`.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_usize</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="number">0</span> <span class="kw">as</span> <span class="ident">usize</span>
    }

    <span class="doccomment">/// Return the internal u32 of this pattern ID.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_u32</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> {
        <span class="self">self</span>.<span class="number">0</span>
    }

    <span class="doccomment">/// Return the internal u32 of this pattern ID represented as an i32.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is guaranteed to never overflow an `i32`.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_i32</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">i32</span> {
        <span class="self">self</span>.<span class="number">0</span> <span class="kw">as</span> <span class="ident">i32</span>
    }

    <span class="doccomment">/// Returns one more than this pattern ID as a usize.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Since a pattern ID has constraints on its maximum value, adding `1` to</span>
    <span class="doccomment">/// it will always fit in a `usize` (and a `u32`).</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">one_more</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="ident">as_usize</span>().<span class="ident">checked_add</span>(<span class="number">1</span>).<span class="ident">unwrap</span>()
    }

    <span class="doccomment">/// Decode this pattern ID from the bytes given using the native endian</span>
    <span class="doccomment">/// byte order for the current target.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the decoded integer is not representable as a pattern ID for the</span>
    <span class="doccomment">/// current target, then this returns an error.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_ne_bytes</span>(<span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">4</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">PatternID</span>, <span class="ident">PatternIDError</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">u32::from_ne_bytes</span>(<span class="ident">bytes</span>);
        <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="ident">PatternID::MAX</span>.<span class="ident">as_u32</span>() {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">PatternIDError</span> { <span class="ident">attempted</span>: <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u64</span> });
        }
        <span class="prelude-val">Ok</span>(<span class="ident">PatternID::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
    }

    <span class="doccomment">/// Decode this pattern ID from the bytes given using the native endian</span>
    <span class="doccomment">/// byte order for the current target.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is analogous to [`PatternID::new_unchecked`] in that is does not</span>
    <span class="doccomment">/// check whether the decoded integer is representable as a pattern ID.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_ne_bytes_unchecked</span>(<span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">4</span>]) -&gt; <span class="ident">PatternID</span> {
        <span class="ident">PatternID::new_unchecked</span>(<span class="ident">u32::from_ne_bytes</span>(<span class="ident">bytes</span>) <span class="kw">as</span> <span class="ident">usize</span>)
    }

    <span class="doccomment">/// Return the underlying pattern ID integer as raw bytes in native endian</span>
    <span class="doccomment">/// format.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">to_ne_bytes</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; [<span class="ident">u8</span>; <span class="number">4</span>] {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">to_ne_bytes</span>()
    }

    <span class="doccomment">/// Returns an iterator over all pattern IDs from 0 up to and not including</span>
    <span class="doccomment">/// the given length.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the given length exceeds [`PatternID::LIMIT`], then this panics.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">iter</span>(<span class="ident">len</span>: <span class="ident">usize</span>) -&gt; <span class="ident">PatternIDIter</span> {
        <span class="ident">PatternIDIter::new</span>(<span class="ident">len</span>)
    }
}

<span class="doccomment">/// This error occurs when a pattern ID could not be constructed.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This occurs when given an integer exceeding the maximum pattern ID value.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When the `std` feature is enabled, this implements the `Error` trait.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PatternIDError</span> {
    <span class="ident">attempted</span>: <span class="ident">u64</span>,
}

<span class="kw">impl</span> <span class="ident">PatternIDError</span> {
    <span class="doccomment">/// Returns the value that failed to constructed a pattern ID.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">attempted</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">attempted</span>
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="kw">impl</span> <span class="ident">std::error::Error</span> <span class="kw">for</span> <span class="ident">PatternIDError</span> {}

<span class="kw">impl</span> <span class="ident">core::fmt::Display</span> <span class="kw">for</span> <span class="ident">PatternIDError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;mut</span> <span class="ident">core::fmt::Formatter</span>) -&gt; <span class="ident">core::fmt::Result</span> {
        <span class="macro">write!</span>(
            <span class="ident">f</span>,
            <span class="string">&quot;failed to create PatternID from {:?}, which exceeds {:?}&quot;</span>,
            <span class="self">self</span>.<span class="ident">attempted</span>(),
            <span class="ident">PatternID::MAX</span>,
        )
    }
}

<span class="doccomment">/// An identifier for a state in a regex engine.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A state ID is guaranteed to be representable by a `usize`. Similarly, the</span>
<span class="doccomment">/// number of states in any regex engine in this crate is guaranteed to be</span>
<span class="doccomment">/// representable by a `usize`. This applies to regex engines that have been</span>
<span class="doccomment">/// deserialized; a deserialization error will be returned if it contains state</span>
<span class="doccomment">/// IDs that violate these requirements in your current environment.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For extra convenience in some cases, this type also guarantees that all</span>
<span class="doccomment">/// IDs can fit into an `i32` and an `isize` without overflowing.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Representation</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This type is always represented internally by a `u32` and is marked as</span>
<span class="doccomment">/// `repr(transparent)`. Thus, this type always has the same representation as</span>
<span class="doccomment">/// a `u32`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Indexing</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For convenience, callers may use a `StateID` to index slices.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Safety</span>
<span class="doccomment">///</span>
<span class="doccomment">/// While a `StateID` is meant to guarantee that its value fits into `usize`</span>
<span class="doccomment">/// (while using a possibly smaller representation than `usize` on some</span>
<span class="doccomment">/// targets), callers must not rely on this property for safety. Callers may</span>
<span class="doccomment">/// choose to rely on this property for correctness however.</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(
    <span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>, <span class="ident">Ord</span>,
)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">StateID</span>(<span class="ident">u32</span>);

<span class="kw">impl</span> <span class="ident">StateID</span> {
    <span class="doccomment">/// The maximum state ID value.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;32&quot;</span>, <span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>))]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX</span>: <span class="ident">StateID</span> <span class="op">=</span>
        <span class="ident">StateID::new_unchecked</span>(<span class="ident">core::i32::MAX</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">-</span> <span class="number">1</span>);

    <span class="doccomment">/// The maximum state ID value.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;16&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX</span>: <span class="ident">StateID</span> <span class="op">=</span> <span class="ident">StateID::new_unchecked</span>(<span class="ident">core::isize::MAX</span> <span class="op">-</span> <span class="number">1</span>);

    <span class="doccomment">/// The total number of states that are allowed in any single regex</span>
    <span class="doccomment">/// engine, represented as a `usize`.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">LIMIT</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">StateID::MAX</span>.<span class="ident">as_usize</span>() <span class="op">+</span> <span class="number">1</span>;

    <span class="doccomment">/// The zero state ID value.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ZERO</span>: <span class="ident">StateID</span> <span class="op">=</span> <span class="ident">StateID::new_unchecked</span>(<span class="number">0</span>);

    <span class="doccomment">/// The number of bytes that a single `StateID` uses in memory.</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SIZE</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">core::mem::size_of</span>::<span class="op">&lt;</span><span class="ident">StateID</span><span class="op">&gt;</span>();

    <span class="doccomment">/// Create a new state ID.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the given identifier exceeds [`StateID::MAX`], then this returns</span>
    <span class="doccomment">/// an error.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">StateID</span>, <span class="ident">StateIDError</span><span class="op">&gt;</span> {
        <span class="ident">StateID::try_from</span>(<span class="ident">id</span>)
    }

    <span class="doccomment">/// Create a new state ID without checking whether the given value</span>
    <span class="doccomment">/// exceeds [`StateID::MAX`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// While this is unchecked, providing an incorrect value must never</span>
    <span class="doccomment">/// sacrifice memory safety, as documented above.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="ident">StateID</span> {
        <span class="ident">StateID</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">u32</span>)
    }

    <span class="doccomment">/// Like [`StateID::new`], but panics if the given ID is not valid.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">must</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="ident">StateID</span> {
        <span class="ident">StateID::new</span>(<span class="ident">id</span>).<span class="ident">unwrap</span>()
    }

    <span class="doccomment">/// Return this state ID as a `usize`.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_usize</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="number">0</span> <span class="kw">as</span> <span class="ident">usize</span>
    }

    <span class="doccomment">/// Return the internal u32 of this state ID.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_u32</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> {
        <span class="self">self</span>.<span class="number">0</span>
    }

    <span class="doccomment">/// Return the internal u32 of this pattern ID represented as an i32.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is guaranteed to never overflow an `i32`.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_i32</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">i32</span> {
        <span class="self">self</span>.<span class="number">0</span> <span class="kw">as</span> <span class="ident">i32</span>
    }

    <span class="doccomment">/// Returns one more than this state ID as a usize.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Since a state ID has constraints on its maximum value, adding `1` to</span>
    <span class="doccomment">/// it will always fit in a `usize` (and a `u32`).</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">one_more</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="ident">as_usize</span>().<span class="ident">checked_add</span>(<span class="number">1</span>).<span class="ident">unwrap</span>()
    }

    <span class="doccomment">/// Decode this state ID from the bytes given using the native endian byte</span>
    <span class="doccomment">/// order for the current target.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the decoded integer is not representable as a state ID for the</span>
    <span class="doccomment">/// current target, then this returns an error.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_ne_bytes</span>(<span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">4</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">StateID</span>, <span class="ident">StateIDError</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">u32::from_ne_bytes</span>(<span class="ident">bytes</span>);
        <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="ident">StateID::MAX</span>.<span class="ident">as_u32</span>() {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">StateIDError</span> { <span class="ident">attempted</span>: <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u64</span> });
        }
        <span class="prelude-val">Ok</span>(<span class="ident">StateID::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
    }

    <span class="doccomment">/// Decode this state ID from the bytes given using the native endian</span>
    <span class="doccomment">/// byte order for the current target.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is analogous to [`StateID::new_unchecked`] in that is does not</span>
    <span class="doccomment">/// check whether the decoded integer is representable as a state ID.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_ne_bytes_unchecked</span>(<span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">4</span>]) -&gt; <span class="ident">StateID</span> {
        <span class="ident">StateID::new_unchecked</span>(<span class="ident">u32::from_ne_bytes</span>(<span class="ident">bytes</span>) <span class="kw">as</span> <span class="ident">usize</span>)
    }

    <span class="doccomment">/// Return the underlying state ID integer as raw bytes in native endian</span>
    <span class="doccomment">/// format.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">to_ne_bytes</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; [<span class="ident">u8</span>; <span class="number">4</span>] {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">to_ne_bytes</span>()
    }

    <span class="doccomment">/// Returns an iterator over all state IDs from 0 up to and not including</span>
    <span class="doccomment">/// the given length.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the given length exceeds [`StateID::LIMIT`], then this panics.</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">iter</span>(<span class="ident">len</span>: <span class="ident">usize</span>) -&gt; <span class="ident">StateIDIter</span> {
        <span class="ident">StateIDIter::new</span>(<span class="ident">len</span>)
    }
}

<span class="doccomment">/// This error occurs when a state ID could not be constructed.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This occurs when given an integer exceeding the maximum state ID value.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When the `std` feature is enabled, this implements the `Error` trait.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">StateIDError</span> {
    <span class="ident">attempted</span>: <span class="ident">u64</span>,
}

<span class="kw">impl</span> <span class="ident">StateIDError</span> {
    <span class="doccomment">/// Returns the value that failed to constructed a state ID.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">attempted</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">attempted</span>
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="kw">impl</span> <span class="ident">std::error::Error</span> <span class="kw">for</span> <span class="ident">StateIDError</span> {}

<span class="kw">impl</span> <span class="ident">core::fmt::Display</span> <span class="kw">for</span> <span class="ident">StateIDError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;mut</span> <span class="ident">core::fmt::Formatter</span>) -&gt; <span class="ident">core::fmt::Result</span> {
        <span class="macro">write!</span>(
            <span class="ident">f</span>,
            <span class="string">&quot;failed to create StateID from {:?}, which exceeds {:?}&quot;</span>,
            <span class="self">self</span>.<span class="ident">attempted</span>(),
            <span class="ident">StateID::MAX</span>,
        )
    }
}

<span class="doccomment">/// A macro for defining exactly identical (modulo names) impls for ID types.</span>
<span class="macro">macro_rules!</span> <span class="ident">impls</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span>:<span class="ident">ident</span>) =&gt; {
        <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
        <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span> {
            <span class="ident">rng</span>: <span class="ident">ops::Range</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>,
        }

        <span class="kw">impl</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span> {
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
            <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">len</span>: <span class="ident">usize</span>) -&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span> {
                <span class="macro">assert!</span>(
                    <span class="ident">len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::LIMIT</span>,
                    <span class="string">&quot;cannot create iterator with IDs when number of \
                     elements exceed {:?}&quot;</span>,
                    <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::LIMIT</span>,
                );
                <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span> { <span class="ident">rng</span>: <span class="number">0</span>..<span class="ident">len</span> }
            }
        }

        <span class="kw">impl</span> <span class="ident">Iterator</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyiter</span> {
            <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>;

            <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="self">self</span>.<span class="ident">rng</span>.<span class="ident">start</span> <span class="op">&gt;</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">rng</span>.<span class="ident">end</span> {
                    <span class="kw">return</span> <span class="prelude-val">None</span>;
                }
                <span class="kw">let</span> <span class="ident">next_id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">rng</span>.<span class="ident">start</span> <span class="op">+</span> <span class="number">1</span>;
                <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">mem::replace</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>.<span class="ident">rng</span>.<span class="ident">start</span>, <span class="ident">next_id</span>);
                <span class="comment">// new_unchecked is OK since we asserted that the number of</span>
                <span class="comment">// elements in this iterator will fit in an ID at construction.</span>
                <span class="prelude-val">Some</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span>))
            }
        }

        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">core::ops::Index</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span><span class="op">&gt;</span> <span class="kw">for</span> [<span class="ident">T</span>] {
            <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">T</span>;

            <span class="attribute">#[<span class="ident">inline</span>]</span>
            <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">T</span> {
                <span class="kw-2">&amp;</span><span class="self">self</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()]
            }
        }

        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">core::ops::IndexMut</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span><span class="op">&gt;</span> <span class="kw">for</span> [<span class="ident">T</span>] {
            <span class="attribute">#[<span class="ident">inline</span>]</span>
            <span class="kw">fn</span> <span class="ident">index_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">index</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>) -&gt; <span class="kw-2">&amp;mut</span> <span class="ident">T</span> {
                <span class="kw-2">&amp;mut</span> <span class="self">self</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()]
            }
        }

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">core::ops::Index</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
            <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">T</span>;

            <span class="attribute">#[<span class="ident">inline</span>]</span>
            <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">T</span> {
                <span class="kw-2">&amp;</span><span class="self">self</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()]
            }
        }

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">core::ops::IndexMut</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
            <span class="attribute">#[<span class="ident">inline</span>]</span>
            <span class="kw">fn</span> <span class="ident">index_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">index</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>) -&gt; <span class="kw-2">&amp;mut</span> <span class="ident">T</span> {
                <span class="kw-2">&amp;mut</span> <span class="self">self</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()]
            }
        }

        <span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span>;

            <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">id</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>.<span class="ident">as_usize</span>() {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span> { <span class="ident">attempted</span>: <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u64</span> });
                }
                <span class="prelude-val">Ok</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span>))
            }
        }

        <span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">Infallible</span>;

            <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">id</span>: <span class="ident">u8</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="ident">Infallible</span><span class="op">&gt;</span> {
                <span class="prelude-val">Ok</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
            }
        }

        <span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span>;

            <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">id</span>: <span class="ident">u16</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u32</span> <span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>.<span class="ident">as_u32</span>() {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span> { <span class="ident">attempted</span>: <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u64</span> });
                }
                <span class="prelude-val">Ok</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
            }
        }

        <span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span>;

            <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">id</span>: <span class="ident">u32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>.<span class="ident">as_u32</span>() {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span> { <span class="ident">attempted</span>: <span class="ident">id</span> <span class="kw">as</span> <span class="ident">u64</span> });
                }
                <span class="prelude-val">Ok</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
            }
        }

        <span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span>;

            <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">id</span>: <span class="ident">u64</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span><span class="op">&gt;</span> {
                <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>.<span class="ident">as_u32</span>() <span class="kw">as</span> <span class="ident">u64</span> {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tyerr</span> { <span class="ident">attempted</span>: <span class="ident">id</span> });
                }
                <span class="prelude-val">Ok</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new_unchecked</span>(<span class="ident">id</span> <span class="kw">as</span> <span class="ident">usize</span>))
            }
        }

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
        <span class="kw">impl</span> <span class="ident">quickcheck::Arbitrary</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
            <span class="kw">fn</span> <span class="ident">arbitrary</span>(<span class="ident">gen</span>: <span class="kw-2">&amp;mut</span> <span class="ident">quickcheck::Gen</span>) -&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span> {
                <span class="kw">use</span> <span class="ident">core::cmp::max</span>;

                <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">max</span>(<span class="ident">i32::MIN</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">i32::arbitrary</span>(<span class="ident">gen</span>)).<span class="ident">abs</span>();
                <span class="kw">if</span> <span class="ident">id</span> <span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>.<span class="ident">as_i32</span>() {
                    <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::MAX</span>
                } <span class="kw">else</span> {
                    <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::new</span>(<span class="ident">usize::try_from</span>(<span class="ident">id</span>).<span class="ident">unwrap</span>()).<span class="ident">unwrap</span>()
                }
            }
        }
    };
}

<span class="macro">impls!</span>(<span class="ident">PatternID</span>, <span class="ident">PatternIDError</span>, <span class="ident">PatternIDIter</span>);
<span class="macro">impls!</span>(<span class="ident">StateID</span>, <span class="ident">StateIDError</span>, <span class="ident">StateIDIter</span>);

<span class="doccomment">/// A utility trait that defines a couple of adapters for making it convenient</span>
<span class="doccomment">/// to access indices as ID types. We require ExactSizeIterator so that</span>
<span class="doccomment">/// iterator construction can do a single check to make sure the index of each</span>
<span class="doccomment">/// element is representable by its ID type.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">trait</span> <span class="ident">IteratorIDExt</span>: <span class="ident">Iterator</span> {
    <span class="kw">fn</span> <span class="ident">with_pattern_ids</span>(<span class="self">self</span>) -&gt; <span class="ident">WithPatternIDIter</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="self">Self</span>: <span class="ident">Sized</span> <span class="op">+</span> <span class="ident">ExactSizeIterator</span>,
    {
        <span class="ident">WithPatternIDIter::new</span>(<span class="self">self</span>)
    }

    <span class="kw">fn</span> <span class="ident">with_state_ids</span>(<span class="self">self</span>) -&gt; <span class="ident">WithStateIDIter</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="self">Self</span>: <span class="ident">Sized</span> <span class="op">+</span> <span class="ident">ExactSizeIterator</span>,
    {
        <span class="ident">WithStateIDIter::new</span>(<span class="self">self</span>)
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Iterator</span><span class="op">&gt;</span> <span class="ident">IteratorIDExt</span> <span class="kw">for</span> <span class="ident">I</span> {}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="macro">macro_rules!</span> <span class="ident">iditer</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">iterty</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span>:<span class="ident">ident</span>) =&gt; {
        <span class="doccomment">/// An iterator adapter that is like std::iter::Enumerate, but attaches</span>
        <span class="doccomment">/// IDs. It requires ExactSizeIterator. At construction, it ensures</span>
        <span class="doccomment">/// that the index of each element in the iterator is representable in</span>
        <span class="doccomment">/// the corresponding ID type.</span>
        <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
        <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span> {
            <span class="ident">it</span>: <span class="ident">I</span>,
            <span class="ident">ids</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">iterty</span>,
        }

        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Iterator</span> <span class="op">+</span> <span class="ident">ExactSizeIterator</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span> {
            <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">it</span>: <span class="ident">I</span>) -&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span> {
                <span class="kw">let</span> <span class="ident">ids</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty::iter</span>(<span class="ident">it</span>.<span class="ident">len</span>());
                <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span> { <span class="ident">it</span>, <span class="ident">ids</span> }
            }
        }

        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Iterator</span> <span class="op">+</span> <span class="ident">ExactSizeIterator</span><span class="op">&gt;</span> <span class="ident">Iterator</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">withiterty</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span> {
            <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="ident">I::Item</span>);

            <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ty</span>, <span class="ident">I::Item</span>)<span class="op">&gt;</span> {
                <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">it</span>.<span class="ident">next</span>()<span class="question-mark">?</span>;
                <span class="comment">// Number of elements in this iterator must match, according</span>
                <span class="comment">// to contract of ExactSizeIterator.</span>
                <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ids</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>();
                <span class="prelude-val">Some</span>((<span class="ident">id</span>, <span class="ident">item</span>))
            }
        }
    };
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="macro">iditer!</span>(<span class="ident">PatternID</span>, <span class="ident">PatternIDIter</span>, <span class="ident">WithPatternIDIter</span>);
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="macro">iditer!</span>(<span class="ident">StateID</span>, <span class="ident">StateIDIter</span>, <span class="ident">WithStateIDIter</span>);
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>