<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A wrapper around a `syn::DeriveInput` which provides utilities for creating custom derive trait implementations."><meta name="keywords" content="rust, rustlang, rust-lang, Structure"><title>Structure in synstructure - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../synstructure/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../synstructure/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Structure</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.add_bounds">add_bounds</a></li><li><a href="#method.add_impl_generic">add_impl_generic</a></li><li><a href="#method.add_trait_bounds">add_trait_bounds</a></li><li><a href="#method.add_where_predicate">add_where_predicate</a></li><li><a href="#method.ast">ast</a></li><li><a href="#method.bind_with">bind_with</a></li><li><a href="#method.binding_name">binding_name</a></li><li><a href="#method.bound_impl">bound_impl</a></li><li><a href="#method.each">each</a></li><li><a href="#method.each_variant">each_variant</a></li><li><a href="#method.filter">filter</a></li><li><a href="#method.filter_variants">filter_variants</a></li><li><a href="#method.fold">fold</a></li><li><a href="#method.gen_impl">gen_impl</a></li><li><a href="#method.new">new</a></li><li><a href="#method.omitted_variants">omitted_variants</a></li><li><a href="#method.referenced_ty_params">referenced_ty_params</a></li><li><a href="#method.remove_variant">remove_variant</a></li><li><a href="#method.try_new">try_new</a></li><li><a href="#method.unbound_impl">unbound_impl</a></li><li><a href="#method.underscore_const">underscore_const</a></li><li><a href="#method.unsafe_bound_impl">unsafe_bound_impl</a></li><li><a href="#method.unsafe_unbound_impl">unsafe_unbound_impl</a></li><li><a href="#method.variants">variants</a></li><li><a href="#method.variants_mut">variants_mut</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-Eq">Eq</a></li><li><a href="#impl-Hash">Hash</a></li><li><a href="#impl-PartialEq%3CStructure%3C%27a%3E%3E">PartialEq&lt;Structure&lt;&#39;a&gt;&gt;</a></li><li><a href="#impl-StructuralEq">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq">StructuralPartialEq</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">!Send</a></li><li><a href="#impl-Sync">!Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In synstructure</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../synstructure/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="index.html">synstructure</a>::<wbr><a class="struct" href="#">Structure</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/synstructure/lib.rs.html#939-947">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Structure&lt;'a&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A wrapper around a <code>syn::DeriveInput</code> which provides utilities for creating
custom derive trait implementations.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#949-2310">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#957-959">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(ast: &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This method will panic if the provided AST node represents an untagged
union.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#966-1021">source</a></span><a href="#method.try_new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_new" class="fnname">try_new</a>(ast: &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; <a class="type" href="../syn/error/type.Result.html" title="type syn::error::Result">Result</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<p>Unlike <code>Structure::new</code>, this method does not panic if the provided AST
node represents an untagged union.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.variants" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1024-1026">source</a></span><a href="#method.variants" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.variants" class="fnname">variants</a>(&amp;self) -&gt; &amp;[<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;]</h4></section></summary><div class="docblock"><p>Returns a slice of the variants in this Structure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.variants_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1029-1031">source</a></span><a href="#method.variants_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.variants_mut" class="fnname">variants_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;]</h4></section></summary><div class="docblock"><p>Returns a mut slice of the variants in this Structure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ast" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1035-1037">source</a></span><a href="#method.ast" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ast" class="fnname">ast</a>(&amp;self) -&gt; &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying <code>syn</code> AST node which this
<code>Structure</code> was created from.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.omitted_variants" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1040-1042">source</a></span><a href="#method.omitted_variants" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.omitted_variants" class="fnname">omitted_variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>True if any variants were omitted due to a <code>filter_variants</code> call.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.each" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1075-1088">source</a></span><a href="#method.each" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.each" class="fnname">each</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each bound field, passing in a <code>BindingInfo</code>.
and generating <code>match</code> arms which evaluate the returned tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A::C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fold" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1123-1137">source</a></span><a href="#method.fold" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fold" class="fnname">fold</a>&lt;F, I, R&gt;(&amp;self, init: I, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>, &amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each bound field, passing in the
result of the previous call, and a <code>BindingInfo</code>. generating <code>match</code>
arms which evaluate to the resulting tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<p>If a variant has been ignored, it will return the <code>init</code> value.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">fold</span>(<span class="macro">quote!</span>(<span class="number">0</span>), <span class="op">|</span><span class="ident">acc</span>, <span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(#<span class="ident">acc</span> <span class="op">+</span> #<span class="ident">bi</span>)).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) =&gt; {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span> <span class="op">+</span> <span class="ident">__binding_1</span>
        }
        <span class="ident">A::C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) =&gt; {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span>
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.each_variant" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1173-1188">source</a></span><a href="#method.each_variant" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.each_variant" class="fnname">each_variant</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'_&gt;) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each variant, passing in a
<code>VariantInfo</code>. and generating <code>match</code> arms which evaluate the returned
tokens.</p>
<p>This method will ignore variants and not bind fields which are ignored
through the <code>filter</code> and <code>filter_variant</code> methods.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each_variant</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span>;
        <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="macro">stringify!</span>(#<span class="ident">name</span>)))
    }).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) =&gt; {
            <span class="macro">println!</span>(<span class="macro">stringify!</span>(<span class="ident">B</span>))
        }
        <span class="ident">A::C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) =&gt; {
            <span class="macro">println!</span>(<span class="macro">stringify!</span>(<span class="ident">C</span>))
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.filter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1227-1235">source</a></span><a href="#method.filter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.filter" class="fnname">filter</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Filter the bindings created by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>The bindings will no longer appear in match arms generated by methods
on this <code>Structure</code> or its subobjects.</p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
non-filtered fields.</p>
</li>
</ul>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>{ <span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span> },
        <span class="ident">C</span>{ <span class="ident">a</span>: <span class="ident">u32</span> },
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> {
    <span class="ident">bi</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">==</span> <span class="prelude-val">Some</span>(<span class="macro">quote::format_ident!</span>(<span class="string">&quot;a&quot;</span>))
});

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, .. } =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        <span class="ident">A::C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_where_predicate" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1276-1279">source</a></span><a href="#method.add_where_predicate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_where_predicate" class="fnname">add_where_predicate</a>(&amp;mut self, pred: <a class="enum" href="../syn/generics/enum.WherePredicate.html" title="enum syn::generics::WherePredicate">WherePredicate</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Specify additional where predicate bounds which should be generated by
impl-generating functions such as <code>gen_impl</code>, <code>bound_impl</code>, and
<code>unsafe_bound_impl</code>.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="comment">// Add an additional where predicate.</span>
<span class="ident">s</span>.<span class="ident">add_where_predicate</span>(<span class="macro">syn::parse_quote!</span>(<span class="ident">T</span>: <span class="ident">std::fmt::Display</span>));

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">std::fmt::Display</span>,
                      <span class="ident">T</span>: <span class="ident">krate::Trait</span>,
                      <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_bounds" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1320-1323">source</a></span><a href="#method.add_bounds" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_bounds" class="fnname">add_bounds</a>(&amp;mut self, mode: <a class="enum" href="enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Specify which bounds should be generated by impl-generating functions
such as <code>gen_impl</code>, <code>bound_impl</code>, and <code>unsafe_bound_impl</code>.</p>
<p>The default behaviour is to generate both field and generic bounds from
type parameters.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="comment">// Limit bounds to only generics.</span>
<span class="ident">s</span>.<span class="ident">add_bounds</span>(<span class="ident">AddBounds::Generics</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">krate::Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.filter_variants" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1359-1369">source</a></span><a href="#method.filter_variants" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.filter_variants" class="fnname">filter_variants</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Filter the variants matched by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>Match arms destructuring these variants will no longer be generated by
methods on this <code>Structure</code></p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
fields in non-fitered variants.</p>
</li>
</ul>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        <span class="kw">_</span> =&gt; {}
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.remove_variant" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1376-1380">source</a></span><a href="#method.remove_variant" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.remove_variant" class="fnname">remove_variant</a>(&amp;mut self, idx: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Remove the variant at the given index.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if the index is out of range.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bind_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1412-1420">source</a></span><a href="#method.bind_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bind_with" class="fnname">bind_with</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; <a class="enum" href="enum.BindStyle.html" title="enum synstructure::BindStyle">BindStyle</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Updates the <code>BindStyle</code> for each of the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">bind_with</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="ident">BindStyle::RefMut</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_1</span>,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A::C</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.binding_name" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1458-1466">source</a></span><a href="#method.binding_name" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.binding_name" class="fnname">binding_name</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../syn/data/struct.Field.html" title="struct syn::data::Field">Field</a>, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Updates the binding name for each fo the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<p>The function will be called with the <code>BindingInfo</code> and its index in the
enclosing variant.</p>
<p>The default name is <code>__binding_{}</code> where <code>{}</code> is replaced with an
increasing number.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>{ <span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span> },
        <span class="ident">C</span>{ <span class="ident">a</span>: <span class="ident">u32</span> },
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">binding_name</span>(<span class="op">|</span><span class="ident">bi</span>, <span class="ident">i</span><span class="op">|</span> <span class="ident">bi</span>.<span class="ident">ident</span>.<span class="ident">clone</span>().<span class="ident">unwrap</span>());

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote!</span>{
        <span class="ident">A::B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, <span class="ident">b</span>: <span class="kw-2">ref</span> <span class="ident">b</span>, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">b</span>) }
        }
        <span class="ident">A::C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
        }
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.referenced_ty_params" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1495-1503">source</a></span><a href="#method.referenced_ty_params" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.referenced_ty_params" class="fnname">referenced_ty_params</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a list of the type parameters which are refrenced in the types
of non-filtered fields / variants.</p>
<h5 id="caveat"><a href="#caveat">Caveat</a></h5>
<p>If the struct contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;C&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">referenced_ty_params</span>(),
    <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="macro">quote::format_ident!</span>(<span class="string">&quot;T&quot;</span>)]
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_impl_generic" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1543-1546">source</a></span><a href="#method.add_impl_generic" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_impl_generic" class="fnname">add_impl_generic</a>(&amp;mut self, param: <a class="enum" href="../syn/generics/enum.GenericParam.html" title="enum syn::generics::GenericParam">GenericParam</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Adds an <code>impl&lt;&gt;</code> generic parameter.
This can be used when the trait to be derived needs some extra generic parameters.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);
<span class="kw">let</span> <span class="ident">generic</span>: <span class="ident">syn::GenericParam</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span>(<span class="ident">X</span>: <span class="ident">krate::AnotherTrait</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">add_impl_generic</span>(<span class="ident">generic</span>)
        .<span class="ident">bound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>),
        <span class="macro">quote!</span>{
                <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    ).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_X_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span>, <span class="ident">X</span>: <span class="ident">krate::AnotherTrait</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">krate</span> :: <span class="ident">Trait</span> <span class="op">&lt;</span> <span class="ident">X</span> <span class="op">&gt;</span>,
                      <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>,
                      <span class="ident">U</span>: <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_trait_bounds" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1556-1621">source</a></span><a href="#method.add_trait_bounds" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_trait_bounds" class="fnname">add_trait_bounds</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;bound: &amp;<a class="struct" href="../syn/generics/struct.TraitBound.html" title="struct syn::generics::TraitBound">TraitBound</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;where_clause: &amp;mut <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../syn/generics/struct.WhereClause.html" title="struct syn::generics::WhereClause">WhereClause</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;mode: <a class="enum" href="enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a><br>)</h4></section></summary><div class="docblock"><p>Add trait bounds for a trait with the given path for each type parmaeter
referenced in the types of non-filtered fields.</p>
<h5 id="caveat-1"><a href="#caveat-1">Caveat</a></h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.underscore_const" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1664-1667">source</a></span><a href="#method.underscore_const" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.underscore_const" class="fnname">underscore_const</a>(&amp;mut self, enabled: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Configure whether to use <code>const _</code> instead of a generated const name in
code generated by <code>gen_impl</code> and <code>bound_impl</code>.</p>
<p>This syntax is only supported by rust 1.37, and later versions.</p>
<p>Defaults to <code>false</code> for backwards compatibility reasons.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">struct</span> <span class="ident">MyStruct</span>;
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">underscore_const</span>(<span class="bool-val">true</span>)
        .<span class="ident">gen_impl</span>(<span class="macro">quote!</span> { <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">Trait</span> <span class="kw">for</span> @<span class="self">Self</span> { } })
        .<span class="ident">to_string</span>(),
    <span class="macro">quote!</span> {
        <span class="kw">const</span> <span class="kw">_</span>: () <span class="op">=</span> {
            <span class="kw">impl</span> <span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">MyStruct</span> { }
        };
    }
    .<span class="ident">to_string</span>()
);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">underscore_const</span>(<span class="bool-val">false</span>)
        .<span class="ident">gen_impl</span>(<span class="macro">quote!</span> { <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">Trait</span> <span class="kw">for</span> @<span class="self">Self</span> { } })
        .<span class="ident">to_string</span>(),
    <span class="macro">quote!</span> {
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_Trait_FOR_MyStruct</span>: () <span class="op">=</span> {
            <span class="kw">impl</span> <span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">MyStruct</span> { }
        };
    }
    .<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bound_impl" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1730-1737">source</a></span><a href="#method.bound_impl" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bound_impl" class="fnname">bound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h5 id="hygiene-and-paths"><a href="#hygiene-and-paths">Hygiene and Paths</a></h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="caveat-2"><a href="#caveat-2">Caveat</a></h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unsafe_bound_impl" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1800-1807">source</a></span><a href="#method.unsafe_bound_impl" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unsafe_bound_impl" class="fnname">unsafe_bound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h5 id="hygiene-and-paths-1"><a href="#hygiene-and-paths-1">Hygiene and Paths</a></h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="caveat-3"><a href="#caveat-3">Caveat</a></h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">unsafe_bound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unbound_impl" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1860-1867">source</a></span><a href="#method.unbound_impl" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unbound_impl" class="fnname">unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h5 id="hygiene-and-paths-2"><a href="#hygiene-and-paths-2">Hygiene and Paths</a></h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">unbound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unsafe_unbound_impl" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#1921-1928">source</a></span><a href="#method.unsafe_unbound_impl" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unsafe_unbound_impl" class="fnname">unsafe_unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated</div></span></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h5 id="hygiene-and-paths-3"><a href="#hygiene-and-paths-3">Hygiene and Paths</a></h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">unsafe_unbound_impl</span>(<span class="macro">quote!</span>(<span class="ident">krate::Trait</span>), <span class="macro">quote!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gen_impl" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#2205-2211">source</a></span><a href="#method.gen_impl" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.gen_impl" class="fnname">gen_impl</a>(&amp;self, cfg: <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><p>Generate an impl block for the given struct. This impl block will
automatically use hygiene tricks to avoid polluting the caller’s
namespace, and will automatically add trait bounds for generic type
parameters.</p>
<h5 id="syntax"><a href="#syntax">Syntax</a></h5>
<p>This function accepts its arguments as a <code>TokenStream</code>. The recommended way
to call this function is passing the result of invoking the <code>quote!</code>
macro to it.</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote!</span> {
    <span class="comment">// You can write any items which you want to import into scope here.</span>
    <span class="comment">// For example, you may want to include an `extern crate` for the</span>
    <span class="comment">// crate which implements your trait. These items will only be</span>
    <span class="comment">// visible to the code you generate, and won&#39;t be exposed to the</span>
    <span class="comment">// consuming crate</span>
    <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;

    <span class="comment">// You can also add `use` statements here to bring types or traits</span>
    <span class="comment">// into scope.</span>
    <span class="comment">//</span>
    <span class="comment">// WARNING: Try not to use common names here, because the stable</span>
    <span class="comment">// version of syn does not support hygiene and you could accidentally</span>
    <span class="comment">// shadow types from the caller crate.</span>
    <span class="kw">use</span> <span class="ident">krate::Trait</span> <span class="kw">as</span> <span class="ident">MyTrait</span>;

    <span class="comment">// The actual impl block is a `gen impl` or `gen unsafe impl` block.</span>
    <span class="comment">// You can use `@Self` to refer to the structure&#39;s type.</span>
    <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">MyTrait</span> <span class="kw">for</span> @<span class="self">Self</span> {
        <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
})</code></pre></div>
<p>The most common usage of this trait involves loading the crate the
target trait comes from with <code>extern crate</code>, and then invoking a <code>gen impl</code> block.</p>
<h5 id="hygiene"><a href="#hygiene">Hygiene</a></h5>
<p>This method tries to handle hygiene intelligenly for both stable and
unstable proc-macro implementations, however there are visible
differences.</p>
<p>The output of every <code>gen_impl</code> function is wrapped in a dummy <code>const</code>
value, to ensure that it is given its own scope, and any values brought
into scope are not leaked to the calling crate.</p>
<p>By default, the above invocation may generate an output like the
following:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_Struct</span>: () <span class="op">=</span> {
    <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
    <span class="kw">use</span> <span class="ident">krate::Trait</span> <span class="kw">as</span> <span class="ident">MyTrait</span>;
    <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">MyTrait</span> <span class="kw">for</span> <span class="ident">Struct</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">MyTrait</span> {
        <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
};</code></pre></div>
<p>The <code>Structure</code> may also be confired with the [<code>underscore_const</code>] method
to generate <code>const _</code> instead.</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">const</span> <span class="kw">_</span>: () <span class="op">=</span> {
    <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
    <span class="kw">use</span> <span class="ident">krate::Trait</span> <span class="kw">as</span> <span class="ident">MyTrait</span>;
    <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">MyTrait</span> <span class="kw">for</span> <span class="ident">Struct</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">MyTrait</span> {
        <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
};</code></pre></div>
<h6 id="using-the-std-crate"><a href="#using-the-std-crate">Using the <code>std</code> crate</a></h6>
<p>If you are using <code>quote!()</code> to implement your trait, with the
<code>proc-macro2/nightly</code> feature, <code>std</code> isn’t considered to be in scope for
your macro. This means that if you use types from <code>std</code> in your
procedural macro, you’ll want to explicitly load it with an <code>extern crate std;</code>.</p>
<h6 id="absolute-paths"><a href="#absolute-paths">Absolute paths</a></h6>
<p>You should generally avoid using absolute paths in your generated code,
as they will resolve very differently when using the stable and nightly
versions of <code>proc-macro2</code>. Instead, load the crates you need to use
explictly with <code>extern crate</code> and</p>
<h5 id="trait-bounds"><a href="#trait-bounds">Trait Bounds</a></h5>
<p>This method will automatically add trait bounds for any type parameters
which are referenced within the types of non-ignored fields.</p>
<p>Additional type parameters may be added with the generics syntax after
the <code>impl</code> keyword.</p>
<h6 id="type-macro-caveat"><a href="#type-macro-caveat">Type Macro Caveat</a></h6>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This function will generate a <code>compile_error!</code> if additional type
parameters added by <code>impl&lt;..&gt;</code> conflict with generic type parameters on
the original struct.</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>This function will panic if the input <code>TokenStream</code> is not well-formed.</p>
<h5 id="example-usage"><a href="#example-usage">Example Usage</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn::DeriveInput</span> <span class="op">=</span> <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure::new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span>,
                <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);

<span class="comment">// NOTE: You can also add extra generics after the impl</span>
<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
        <span class="ident">gen</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">X</span>: <span class="ident">krate::OtherTrait</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> @<span class="self">Self</span>
        <span class="kw">where</span>
            <span class="ident">X</span>: <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span>,
        {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_X_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">X</span>: <span class="ident">krate::OtherTrait</span>, <span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="ident">X</span>: <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span>,
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>,
                <span class="ident">U</span>: <span class="ident">krate::Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);

<span class="comment">// NOTE: you can generate multiple traits with a single call</span>
<span class="macro">assert_eq!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;

        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }

        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate::OtherTrait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">b</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::Trait</span>,
                <span class="ident">U</span>: <span class="ident">krate::Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }

            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate::OtherTrait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate::OtherTrait</span>,
                <span class="ident">U</span>: <span class="ident">krate::OtherTrait</span>
            {
                <span class="kw">fn</span> <span class="ident">b</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</code></pre></div>
<p>Use <code>add_bounds</code> to change which bounds are generated.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/clone.rs.html#133-135">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;__H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>__H)</h4></section></summary><div class='docblock'><p>Feeds this value into the given <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CStructure%3C%27a%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-PartialEq%3CStructure%3C%27a%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;&gt; for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><section id="impl-Eq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-StructuralEq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-StructuralEq" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-StructuralPartialEq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/synstructure/lib.rs.html#938">source</a></span><a href="#impl-StructuralPartialEq" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#203-207">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#204">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#83-95">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#88">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#92">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="synstructure" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>