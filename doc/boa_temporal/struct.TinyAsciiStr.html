<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `TinyAsciiStr` struct in crate `boa_temporal`."><title>TinyAsciiStr in boa_temporal - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="boa_temporal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/boa-dev/boa/main/assets/logo.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../boa_temporal/index.html"><img src="https://raw.githubusercontent.com/boa-dev/boa/main/assets/logo.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../boa_temporal/index.html"><img src="https://raw.githubusercontent.com/boa-dev/boa/main/assets/logo.svg" alt="logo"></a><h2><a href="../boa_temporal/index.html">boa_temporal</a><span class="version">0.17.0</span></h2></div><h2 class="location"><a href="#">TinyAsciiStr</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.bytes">bytes</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_bytes">all_bytes</a></li><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_str">as_str</a></li><li><a href="#method.from_bytes">from_bytes</a></li><li><a href="#method.from_bytes_manual_slice">from_bytes_manual_slice</a></li><li><a href="#method.from_bytes_unchecked">from_bytes_unchecked</a></li><li><a href="#method.from_str">from_str</a></li><li><a href="#method.is_ascii_alphabetic">is_ascii_alphabetic</a></li><li><a href="#method.is_ascii_alphabetic_lowercase">is_ascii_alphabetic_lowercase</a></li><li><a href="#method.is_ascii_alphabetic_titlecase">is_ascii_alphabetic_titlecase</a></li><li><a href="#method.is_ascii_alphabetic_uppercase">is_ascii_alphabetic_uppercase</a></li><li><a href="#method.is_ascii_alphanumeric">is_ascii_alphanumeric</a></li><li><a href="#method.is_ascii_lowercase">is_ascii_lowercase</a></li><li><a href="#method.is_ascii_numeric">is_ascii_numeric</a></li><li><a href="#method.is_ascii_titlecase">is_ascii_titlecase</a></li><li><a href="#method.is_ascii_uppercase">is_ascii_uppercase</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.len">len</a></li><li><a href="#method.resize">resize</a></li><li><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_titlecase">to_ascii_titlecase</a></li><li><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_unvalidated">to_unvalidated</a></li><li><a href="#method.try_from_raw">try_from_raw</a></li></ul><h3><a href="#deref-methods-str">Methods from Deref&lt;Target=str&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.as_ascii">as_ascii</a></li><li><a href="#method.as_bytes-1">as_bytes</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug">escape_debug</a></li><li><a href="#method.escape_default">escape_default</a></li><li><a href="#method.escape_unicode">escape_unicode</a></li><li><a href="#method.find">find</a></li><li><a href="#method.floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty-1">is_empty</a></li><li><a href="#method.len-1">len</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_any">lines_any</a></li><li><a href="#method.match_indices">match_indices</a></li><li><a href="#method.matches">matches</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches">rmatches</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.slice_unchecked">slice_unchecked</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_once">split_once</a></li><li><a href="#method.split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace">split_whitespace</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.to_ascii_lowercase-1">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase-1">to_ascii_uppercase</a></li><li><a href="#method.to_lowercase">to_lowercase</a></li><li><a href="#method.to_uppercase">to_uppercase</a></li><li><a href="#method.trim">trim</a></li><li><a href="#method.trim_end">trim_end</a></li><li><a href="#method.trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left">trim_left</a></li><li><a href="#method.trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches">trim_matches</a></li><li><a href="#method.trim_right">trim_right</a></li><li><a href="#method.trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start">trim_start</a></li><li><a href="#method.trim_start_matches">trim_start_matches</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsULE-for-TinyAsciiStr%3CN%3E">AsULE</a></li><li><a href="#impl-Bake-for-TinyAsciiStr%3CN%3E">Bake</a></li><li><a href="#impl-Clone-for-TinyAsciiStr%3CN%3E">Clone</a></li><li><a href="#impl-Copy-for-TinyAsciiStr%3CN%3E">Copy</a></li><li><a href="#impl-Debug-for-TinyAsciiStr%3CN%3E">Debug</a></li><li><a href="#impl-Deref-for-TinyAsciiStr%3CN%3E">Deref</a></li><li><a href="#impl-Deserialize%3C'de%3E-for-TinyAsciiStr%3CN%3E">Deserialize&lt;&#x27;de&gt;</a></li><li><a href="#impl-Display-for-TinyAsciiStr%3CN%3E">Display</a></li><li><a href="#impl-Eq-for-TinyAsciiStr%3CN%3E">Eq</a></li><li><a href="#impl-From%3CAttribute%3E-for-TinyAsciiStr%3C8%3E">From&lt;Attribute&gt;</a></li><li><a href="#impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E">From&lt;Key&gt;</a></li><li><a href="#impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E-1">From&lt;Key&gt;</a></li><li><a href="#impl-From%3CLanguage%3E-for-TinyAsciiStr%3C3%3E">From&lt;Language&gt;</a></li><li><a href="#impl-From%3CRegion%3E-for-TinyAsciiStr%3C3%3E">From&lt;Region&gt;</a></li><li><a href="#impl-From%3CScript%3E-for-TinyAsciiStr%3C4%3E">From&lt;Script&gt;</a></li><li><a href="#impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E">From&lt;Subtag&gt;</a></li><li><a href="#impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E-1">From&lt;Subtag&gt;</a></li><li><a href="#impl-From%3CVariant%3E-for-TinyAsciiStr%3C8%3E">From&lt;Variant&gt;</a></li><li><a href="#impl-FromStr-for-TinyAsciiStr%3CN%3E">FromStr</a></li><li><a href="#impl-Hash-for-TinyAsciiStr%3CN%3E">Hash</a></li><li><a href="#impl-Ord-for-TinyAsciiStr%3CN%3E">Ord</a></li><li><a href="#impl-PartialEq-for-TinyAsciiStr%3CN%3E">PartialEq</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E">PartialEq&lt;&amp;str&gt;</a></li><li><a href="#impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E">PartialEq&lt;String&gt;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialOrd-for-TinyAsciiStr%3CN%3E">PartialOrd</a></li><li><a href="#impl-Serialize-for-TinyAsciiStr%3CN%3E">Serialize</a></li><li><a href="#impl-StructuralEq-for-TinyAsciiStr%3CN%3E">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E">StructuralPartialEq</a></li><li><a href="#impl-ULE-for-TinyAsciiStr%3CN%3E">ULE</a></li><li><a href="#impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E">ZeroMapKV&lt;&#x27;a&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-TinyAsciiStr%3CN%3E">Send</a></li><li><a href="#impl-Sync-for-TinyAsciiStr%3CN%3E">Sync</a></li><li><a href="#impl-Unpin-for-TinyAsciiStr%3CN%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-TinyAsciiStr%3CN%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-DeserializeOwned-for-T">DeserializeOwned</a></li><li><a href="#impl-ErasedDestructor-for-T">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-MaybeSendSync-for-T">MaybeSendSync</a></li><li><a href="#impl-Serialize-for-T">Serialize</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-ToString-for-T">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate boa_temporal</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">boa_temporal</a>::<wbr><a class="struct" href="#">TinyAsciiStr</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code><div class="code-attribute">#[repr(transparent)]</div>pub struct TinyAsciiStr&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; {
    bytes: [AsciiByte; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.array.html">N</a>],
}</code></pre><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.bytes" class="structfield small-section-header"><a href="#structfield.bytes" class="anchor field">§</a><code>bytes: [AsciiByte; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.array.html">N</a>]</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method"><h4 class="code-header">pub const fn <a href="#method.from_bytes" class="fn">from_bytes</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, TinyStrError&gt;</h4></section></summary><div class="docblock"><p>Creates a <code>TinyAsciiStr&lt;N&gt;</code> from the given byte slice.
<code>bytes</code> may contain at most <code>N</code> non-null ASCII bytes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_raw" class="method"><h4 class="code-header">pub const fn <a href="#method.try_from_raw" class="fn">try_from_raw</a>(raw: [<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.array.html">N</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, TinyStrError&gt;</h4></section></summary><div class="docblock"><p>Attempts to parse a fixed-length byte array to a <code>TinyAsciiStr</code>.</p>
<p>The byte array may contain trailing NUL bytes.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::tinystr;
<span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="macro">assert_eq!</span>(
    TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b&quot;GB\0&quot;</span>),
    <span class="prelude-val">Ok</span>(<span class="macro">tinystr!</span>(<span class="number">3</span>, <span class="string">&quot;GB&quot;</span>))
);
<span class="macro">assert_eq!</span>(
    TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b&quot;USD&quot;</span>),
    <span class="prelude-val">Ok</span>(<span class="macro">tinystr!</span>(<span class="number">3</span>, <span class="string">&quot;USD&quot;</span>))
);
<span class="macro">assert!</span>(<span class="macro">matches!</span>(TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b&quot;\0A\0&quot;</span>), <span class="prelude-val">Err</span>(<span class="kw">_</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes_manual_slice" class="method"><h4 class="code-header">pub const fn <a href="#method.from_bytes_manual_slice" class="fn">from_bytes_manual_slice</a>(
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, TinyStrError&gt;</h4></section></summary><div class="docblock"><p>Equivalent to <a href="struct.TinyAsciiStr.html#method.from_bytes" title="associated function boa_temporal::TinyAsciiStr::from_bytes"><code>from_bytes(bytes[start..end])</code></a>,
but callable in a <code>const</code> context (which range indexing is not).</p>
</div></details><section id="method.from_str" class="method"><h4 class="code-header">pub const fn <a href="#method.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, TinyStrError&gt;</h4></section><section id="method.as_str" class="method"><h4 class="code-header">pub const fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section><section id="method.len" class="method"><h4 class="code-header">pub const fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a></h4></section><section id="method.is_empty" class="method"><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section><section id="method.as_bytes" class="method"><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section><section id="method.all_bytes" class="method"><h4 class="code-header">pub const fn <a href="#method.all_bytes" class="fn">all_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.array.html">N</a>]</h4></section><details class="toggle method-toggle" open><summary><section id="method.resize" class="method"><h4 class="code-header">pub const fn <a href="#method.resize" class="fn">resize</a>&lt;const M: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;M&gt;</h4></section></summary><div class="docblock"><p>Resizes a <code>TinyAsciiStr&lt;N&gt;</code> to a <code>TinyAsciiStr&lt;M&gt;</code>.</p>
<p>If <code>M &lt; len()</code> the string gets truncated, otherwise only the
memory representation changes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes_unchecked" class="method"><h4 class="code-header">pub const unsafe fn <a href="#method.from_bytes_unchecked" class="fn">from_bytes_unchecked</a>(bytes: [<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.array.html">N</a>]) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class="docblock"><h5 id="safety"><a href="#safety">Safety</a></h5>
<p>Must be called with a bytes array made of valid ASCII bytes, with no null bytes
between ASCII characters</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-1" class="impl"><a href="#impl-TinyAsciiStr%3CN%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic" class="fn">is_ascii_alphabetic</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’, or</li>
<li>U+0061 ‘a’ ..= U+007A ‘z’.</li>
</ul>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Te3t&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphabetic());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphanumeric" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphanumeric" class="fn">is_ascii_alphanumeric</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphanumeric characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’, or</li>
<li>U+0061 ‘a’ ..= U+007A ‘z’, or</li>
<li>U+0030 ‘0’ ..= U+0039 ‘9’.</li>
</ul>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;A15b&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;[3@w&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphanumeric());
<span class="macro">assert!</span>(!s2.is_ascii_alphanumeric());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_numeric" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_numeric" class="fn">is_ascii_numeric</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII decimal digits:</p>
<ul>
<li>U+0030 ‘0’ ..= U+0039 ‘9’.</li>
</ul>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;312&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;3d&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(s1.is_ascii_numeric());
<span class="macro">assert!</span>(!s2.is_ascii_numeric());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_lowercase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_lowercase" class="fn">is_ascii_lowercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII lower case.</p>
<p>All letter characters are checked for case. Non-letter characters are ignored.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(!s1.is_ascii_lowercase());
<span class="macro">assert!</span>(s2.is_ascii_lowercase());
<span class="macro">assert!</span>(s3.is_ascii_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_titlecase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_titlecase" class="fn">is_ascii_titlecase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII title case.</p>
<p>This verifies that the first character is ASCII uppercase and all others ASCII lowercase.
Non-letter characters are ignored.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(!s1.is_ascii_titlecase());
<span class="macro">assert!</span>(s2.is_ascii_titlecase());
<span class="macro">assert!</span>(s3.is_ascii_titlecase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_uppercase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_uppercase" class="fn">is_ascii_uppercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII upper case.</p>
<p>All letter characters are checked for case. Non-letter characters are ignored.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;TEST&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(!s1.is_ascii_uppercase());
<span class="macro">assert!</span>(s2.is_ascii_uppercase());
<span class="macro">assert!</span>(!s3.is_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_lowercase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_lowercase" class="fn">is_ascii_alphabetic_lowercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic lower case characters:</p>
<ul>
<li>U+0061 ‘a’ ..= U+007A ‘z’,</li>
</ul>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Te3t&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(!s1.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(s4.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_titlecase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_titlecase" class="fn">is_ascii_alphabetic_titlecase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic, with the first character being ASCII uppercase, and all others ASCII lowercase.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Te3t&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s4.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_titlecase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_uppercase" class="method"><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_uppercase" class="fn">is_ascii_alphabetic_uppercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic upper case characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’,</li>
</ul>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Test&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Te3t&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;TEST&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;001z&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert!</span>(!s1.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(s4.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_uppercase());</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-2" class="impl"><a href="#impl-TinyAsciiStr%3CN%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><h4 class="code-header">pub const fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, other characters are unchanged.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;TeS3&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_lowercase(), <span class="string">&quot;tes3&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_titlecase" class="method"><h4 class="code-header">pub const fn <a href="#method.to_ascii_titlecase" class="fn">to_ascii_titlecase</a>(self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII title case equivalent in-place.</p>
<p>The first character is converted to ASCII uppercase; the remaining characters
are converted to ASCII lowercase.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;teSt&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_titlecase(), <span class="string">&quot;Test&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><h4 class="code-header">pub const fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, other characters are unchanged.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">&quot;Tes3&quot;</span>.parse().expect(<span class="string">&quot;Failed to parse.&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_uppercase(), <span class="string">&quot;TES3&quot;</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-3" class="impl"><a href="#impl-TinyAsciiStr%3CN%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><section id="method.to_unvalidated" class="method"><h4 class="code-header">pub const fn <a href="#method.to_unvalidated" class="fn">to_unvalidated</a>(self) -&gt; UnvalidatedTinyAsciiStr&lt;N&gt;</h4></section></div></details></div><h2 id="deref-methods-str" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;</span><a href="#deref-methods-str" class="anchor">§</a></h2><div id="deref-methods-str-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#164">source</a></span><h4 class="code-header">pub fn <a href="#method.len-1" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">&quot;foo&quot;</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">&quot;ƒoo&quot;</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">&quot;ƒoo&quot;</span>.chars().count(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#183">source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty-1" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;&quot;</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#213">source</a></span><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `老`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `ö`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `老`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#260">source</a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>This method can help you truncate a string so that it’s still valid UTF-8, but doesn’t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters aren’t
split. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only
includes 🧑 (person) instead.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">&quot;❤️🧡💛💚💙💜&quot;</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">&quot;❤️🧡&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#298">source</a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">&quot;❤️🧡💛💚💙💜&quot;</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">&quot;❤️🧡💛&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#324">source</a></span><h4 class="code-header">pub fn <a href="#method.as_bytes-1" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="https://doc.rust-lang.org/1.75.0/core/str/converts/fn.from_utf8.html" title="fn core::str::converts::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">&quot;bors&quot;</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b&quot;bors&quot;</span>, bytes);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#398">source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#439">source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a>&gt;<span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">&quot;🗻∈🌏&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;🗻&quot;</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#503">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">&quot;🗻∈🌏&quot;</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;🗻&quot;</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;∈&quot;</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;🌏&quot;</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#589">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html" title="primitive str"><code>str</code></a> and <a href="https://doc.rust-lang.org/1.75.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;Löwe 老虎 Léopard&quot;</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;world&quot;</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#660">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Per Martin-Löf&quot;</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Per&quot;</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-Löf&quot;</span>, last);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#768">source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.Chars.html" title="struct core::str::iter::Chars">Chars</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>It’s important to remember that <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a ‘character’ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rust’s standard library, check crates.io instead.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">&quot;y̆&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), chars.next()); <span class="comment">// not &#39;y̆&#39;
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#825">source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.CharIndices.html" title="struct core::str::iter::CharIndices">CharIndices</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">&quot;y̆es&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), char_indices.next()); <span class="comment">// not (0, &#39;y̆&#39;)
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), char_indices.next());

<span class="comment">// note the 3 here - the previous character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#848">source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.Bytes.html" title="struct core::str::iter::Bytes">Bytes</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">&quot;bors&quot;</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#900">source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.SplitWhitespace.html" title="struct core::str::iter::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot;A few words&quot;</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;   &quot;</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#949">source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.SplitAsciiWhitespace.html" title="struct core::str::iter::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot;A few words&quot;</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot; Mary   had\ta little  \n\t lamb&quot;</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;   &quot;</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1002">source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.Lines.html" title="struct core::str::iter::Lines">Lines</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;foo\r\nbar\n\nbaz\r&quot;</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz\r&quot;</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1011">source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.LinesAny.html" title="struct core::str::iter::LinesAny">LinesAny</a>&lt;'_&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>An iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1030">source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.EncodeUtf16.html" title="struct core::str::iter::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;Zażółć gęślą jaźń&quot;</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1055">source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">&quot;apples&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1079">source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">&quot;nana&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1103-1105">source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">&quot;nana&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1154">source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">&#39;o&#39;</span>) &amp;&amp; (c &gt; <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1200-1202">source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1322">source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.Split.html" title="struct core::str::iter::Split">Split</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior"><a href="#iterator-behavior">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.split(<span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.split(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.split(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.split(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1def2ghi&quot;</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXtigerXleopard&quot;</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</code></pre></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;2020-11-03 23:59&quot;</span>.split(<span class="kw-2">&amp;</span>[<span class="string">&#39;-&#39;</span>, <span class="string">&#39; &#39;</span>, <span class="string">&#39;:&#39;</span>, <span class="string">&#39;@&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;2020&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;03&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;59&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.split(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;||||a||b|c&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39;|&#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;(///)&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39;/&#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;010&quot;</span>.split(<span class="string">&quot;0&quot;</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;rust&quot;</span>.split(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;    a  b c&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39; &#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>Use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1362">source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.SplitInclusive.html" title="struct core::str::iter::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern. Differs from the iterator produced by
<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the
terminator of the substring.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.&quot;
    </span>.split_inclusive(<span class="string">&#39;\n&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.&quot;</span>]);</code></pre></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.\n&quot;
    </span>.split_inclusive(<span class="string">&#39;\n&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.\n&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1417-1419">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.RSplit.html" title="struct core::str::iter::RSplit">RSplit</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a href="#iterator-behavior-1">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.rsplit(<span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.rsplit(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.rsplit(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.rsplit(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.rsplit(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1466">source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.SplitTerminator.html" title="struct core::str::iter::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a href="#iterator-behavior-2">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B.&quot;</span>.split_terminator(<span class="string">&#39;.&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A..B..&quot;</span>.split_terminator(<span class="string">&quot;.&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B:C.D&quot;</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1512-1514">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.RSplitTerminator.html" title="struct core::str::iter::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a href="#iterator-behavior-3">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B.&quot;</span>.rsplit_terminator(<span class="string">&#39;.&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A..B..&quot;</span>.rsplit_terminator(<span class="string">&quot;.&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B:C.D&quot;</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1567">source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.SplitN.html" title="struct core::str::iter::SplitN">SplitN</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a href="#iterator-behavior-4">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lambda&quot;</span>.splitn(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.splitn(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXdef&quot;</span>.splitn(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.splitn(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1616-1618">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.RSplitN.html" title="struct core::str::iter::RSplitN">RSplitN</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a href="#iterator-behavior-5">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.rsplitn(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.rsplitn(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.rsplitn(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1636">source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>)&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo=bar&quot;</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1654-1656">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>)&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg=foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1694">source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.Matches.html" title="struct core::str::iter::Matches">Matches</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a href="#iterator-behavior-6">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.matches(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;1abc2abc3&quot;</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1728-1730">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.RMatches.html" title="struct core::str::iter::RMatches">RMatches</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a href="#iterator-behavior-7">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.rmatches(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;1abc2abc3&quot;</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1772">source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.MatchIndices.html" title="struct core::str::iter::MatchIndices">MatchIndices</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a href="#iterator-behavior-8">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.match_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;1abcabc2&quot;</span>.match_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;ababa&quot;</span>.match_indices(<span class="string">&quot;aba&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1812-1814">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.RMatchIndices.html" title="struct core::str::iter::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a href="#iterator-behavior-9">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.75.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.rmatch_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;1abcabc2&quot;</span>.rmatch_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;ababa&quot;</span>.rmatch_indices(<span class="string">&quot;aba&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1836">source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, s.trim());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1875">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a href="#text-directionality">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t\n&quot;</span>, s.trim_start());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">&quot;  עברית  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ע&#39;</span>) == s.trim_start().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1914">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a href="#text-directionality-1">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;\n Hello\tworld&quot;</span>, s.trim_end());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">&quot;  עברית  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ת&#39;</span>) == s.trim_end().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1954">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a href="#text-directionality-2">Text directionality</a></h5>
<p>A string is a sequence of bytes. ‘Left’ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, s.trim_left());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">&quot;  עברית&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ע&#39;</span>) == s.trim_left().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#1994">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a href="#text-directionality-3">Text directionality</a></h5>
<p>A string is a sequence of bytes. ‘Right’ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, s.trim_right());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">&quot;עברית  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ת&#39;</span>) == s.trim_right().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2027-2029">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_matches(char::is_numeric), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_matches(x), <span class="string">&quot;foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.trim_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2074">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a href="#text-directionality-4">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_start_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_start_matches(char::is_numeric), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_start_matches(x), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2107">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped
in <code>Some</code>.  Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.strip_prefix(<span class="string">&quot;foo:&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.strip_prefix(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.strip_prefix(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2134-2137">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.strip_suffix(<span class="string">&quot;:foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.strip_suffix(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.strip_suffix(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2178-2180">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a href="#text-directionality-5">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_end_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_end_matches(char::is_numeric), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_end_matches(x), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.trim_end_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2222">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a href="#text-directionality-6">Text directionality</a></h5>
<p>A string is a sequence of bytes. ‘Left’ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-58"><a href="#examples-58">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_left_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_left_matches(char::is_numeric), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_left_matches(x), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2265-2267">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.75.0/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a href="#text-directionality-7">Text directionality</a></h5>
<p>A string is a sequence of bytes. ‘Right’ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-59"><a href="#examples-59">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_right_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_right_matches(char::is_numeric), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_right_matches(x), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.trim_right_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2317">source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>,</span></h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times you’ll see
the syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
you’re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>Will return <a href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="associated type core::str::traits::FromStr::Err"><code>Err</code></a> if it’s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-60"><a href="#examples-60">Examples</a></h5>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">&quot;4&quot;</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre></div>
<p>Using the ‘turbofish’ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">&quot;4&quot;</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">&quot;j&quot;</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2336">source</a></span><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-61"><a href="#examples-61">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let </span>non_ascii = <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2348">source</a><h4 class="code-header">pub fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="enum" href="https://doc.rust-lang.org/1.75.0/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">AsciiChar</a>]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="https://doc.rust-lang.org/1.75.0/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2368">source</a></span><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-62"><a href="#examples-62">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">&quot;Ferris&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert!</span>(<span class="string">&quot;Ferrös&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRöS&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">&quot;Ferrös&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRÖS&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2463">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.EscapeDebug.html" title="struct core::str::iter::EscapeDebug">EscapeDebug</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-63"><a href="#examples-63">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;❤\n!&quot;</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.escape_debug());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;❤\\n!&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;❤\n!&quot;</span>.escape_debug().to_string(), <span class="string">&quot;❤\\n!&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2509">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.EscapeDefault.html" title="struct core::str::iter::EscapeDefault">EscapeDefault</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-64"><a href="#examples-64">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;❤\n!&quot;</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.escape_default());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\n!&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;❤\n!&quot;</span>.escape_default().to_string(), <span class="string">&quot;\\u{2764}\\n!&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/str/mod.rs.html#2547">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/str/iter/struct.EscapeUnicode.html" title="struct core::str::iter::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.75.0/std/primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-65"><a href="#examples-65">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;❤\n!&quot;</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.escape_unicode());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\u{{a}}\\u{{21}}&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;❤\n!&quot;</span>.escape_unicode().to_string(), <span class="string">&quot;\\u{2764}\\u{a}\\u{21}&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#269">source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-66"><a href="#examples-66">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;this is new&quot;</span>, s.replace(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;than an old&quot;</span>, s.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;an&quot;</span>));</code></pre></div>
<p>When the pattern doesn’t match, it returns this string slice as <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(s, s.replace(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#309">source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-67"><a href="#examples-67">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, s.replacen(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, s.replacen(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, s.replacen(char::is_numeric, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</code></pre></div>
<p>When the pattern doesn’t match, it returns this string slice as <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(s, s.replacen(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#366">source</a></span><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fn">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>‘Lowercase’ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-68"><a href="#examples-68">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, s.to_lowercase());</code></pre></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sigma = <span class="string">&quot;Σ&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;σ&quot;</span>, sigma.to_lowercase());

<span class="comment">// but at the end of a word, it&#39;s ς, not σ:
</span><span class="kw">let </span>odysseus = <span class="string">&quot;ὈΔΥΣΣΕΎΣ&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;ὀδυσσεύς&quot;</span>, odysseus.to_lowercase());</code></pre></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#457">source</a></span><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fn">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>‘Uppercase’ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-69"><a href="#examples-69">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;HELLO&quot;</span>, s.to_uppercase());</code></pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;tschüß&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;TSCHÜSS&quot;</span>, s.to_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#527">source</a></span><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Creates a new <a href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-70"><a href="#examples-70">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;abc&quot;</span>.repeat(<span class="number">4</span>), String::from(<span class="string">&quot;abcabcabcabc&quot;</span>));</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// this will panic at runtime
</span><span class="kw">let </span>huge = <span class="string">&quot;0123456789abcdef&quot;</span>.repeat(usize::MAX);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#557">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase-1" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-71"><a href="#examples-71">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;GRüßE, JüRGEN ❤&quot;</span>, s.to_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/alloc/str.rs.html#589">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase-1" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-72"><a href="#examples-72">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;grüße, jürgen ❤&quot;</span>, s.to_ascii_lowercase());</code></pre></div>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsULE-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-AsULE-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; AsULE for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.ULE" class="associatedtype trait-impl"><a href="#associatedtype.ULE" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">ULE</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The ULE type corresponding to <code>Self</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_unaligned" class="method trait-impl"><a href="#method.to_unaligned" class="anchor">§</a><h4 class="code-header">fn <a class="fn">to_unaligned</a>(self) -&gt; &lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt; as AsULE&gt;::ULE</h4></section></summary><div class='docblock'>Converts from <code>Self</code> to <code>Self::ULE</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.from_unaligned" class="method trait-impl"><a href="#method.from_unaligned" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from_unaligned</a>(unaligned: &lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt; as AsULE&gt;::ULE) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>Converts from <code>Self::ULE</code> to <code>Self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Bake-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Bake-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; Bake for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.bake" class="method trait-impl"><a href="#method.bake" class="anchor">§</a><h4 class="code-header">fn <a class="fn">bake</a>(&amp;self, env: &amp;CrateEnv) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.76/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class='docblock'>Returns a <a href="https://docs.rs/proc-macro2/1.0.76/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream"><code>TokenStream</code></a> that would evaluate to <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Clone-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Debug-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Deref-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.75.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deserialize%3C'de%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Deserialize%3C'de%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'de, const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deserialize" class="method trait-impl"><a href="#method.deserialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserialize.html#tymethod.deserialize" class="fn">deserialize</a>&lt;D&gt;(
    deserializer: D
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, &lt;D as <a class="trait" href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;&gt;::<a class="associatedtype" href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserializer.html#associatedtype.Error" title="type serde::de::Deserializer::Error">Error</a>&gt;<span class="where fmt-newline">where
    D: <a class="trait" href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;,</span></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer. <a href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserialize.html#tymethod.deserialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Display-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CAttribute%3E-for-TinyAsciiStr%3C8%3E" class="impl"><a href="#impl-From%3CAttribute%3E-for-TinyAsciiStr%3C8%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Attribute&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Attribute) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E" class="impl"><a href="#impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Key&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;2&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Key) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;2&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E-1" class="impl"><a href="#impl-From%3CKey%3E-for-TinyAsciiStr%3C2%3E-1" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Key&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;2&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Key) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;2&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CLanguage%3E-for-TinyAsciiStr%3C3%3E" class="impl"><a href="#impl-From%3CLanguage%3E-for-TinyAsciiStr%3C3%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Language&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;3&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Language) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;3&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CRegion%3E-for-TinyAsciiStr%3C3%3E" class="impl"><a href="#impl-From%3CRegion%3E-for-TinyAsciiStr%3C3%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Region&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;3&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Region) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;3&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CScript%3E-for-TinyAsciiStr%3C4%3E" class="impl"><a href="#impl-From%3CScript%3E-for-TinyAsciiStr%3C4%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Script&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;4&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Script) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;4&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E" class="impl"><a href="#impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Subtag&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Subtag) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E-1" class="impl"><a href="#impl-From%3CSubtag%3E-for-TinyAsciiStr%3C8%3E-1" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Subtag&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a href="#method.from-8" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Subtag) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CVariant%3E-for-TinyAsciiStr%3C8%3E" class="impl"><a href="#impl-From%3CVariant%3E-for-TinyAsciiStr%3C8%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Variant&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(input: Variant) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;8&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-FromStr-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = TinyStrError</h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str-1" class="method trait-impl"><a href="#method.from_str-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;, TinyStrError&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.75.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Hash-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;mut __H</a>)<span class="where fmt-newline">where
    __H: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/hash/mod.rs.html#242-244">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.75.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Ord-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.75.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#826-828">source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#846-848">source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#871-874">source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>,</span></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a href="#method.eq-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#239">source</a></span><a href="#method.ne-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#239">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#239">source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-PartialEq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#239">source</a></span><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-PartialOrd-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.75.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#1122">source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#1139">source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#1155">source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.75.0/src/core/cmp.rs.html#1172">source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Serialize-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Serialize-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.serialize" class="method trait-impl"><a href="#method.serialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serialize.html#tymethod.serialize" class="fn">serialize</a>&lt;S&gt;(
    &amp;self,
    serializer: S
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&lt;S as <a class="trait" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serializer.html#associatedtype.Ok" title="type serde::ser::Serializer::Ok">Ok</a>, &lt;S as <a class="trait" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>&gt;::<a class="associatedtype" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serializer.html#associatedtype.Error" title="type serde::ser::Serializer::Error">Error</a>&gt;<span class="where fmt-newline">where
    S: <a class="trait" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>,</span></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serialize.html#tymethod.serialize">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ULE-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-ULE-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; ULE for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.validate_byte_slice" class="method trait-impl"><a href="#method.validate_byte_slice" class="anchor">§</a><h4 class="code-header">fn <a class="fn">validate_byte_slice</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.unit.html">()</a>, ZeroVecError&gt;</h4></section></summary><div class='docblock'>Validates a byte slice, <code>&amp;[u8]</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.parse_byte_slice" class="method trait-impl"><a href="#method.parse_byte_slice" class="anchor">§</a><h4 class="code-header">fn <a class="fn">parse_byte_slice</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.slice.html">[Self]</a>, ZeroVecError&gt;</h4></section></summary><div class='docblock'>Parses a byte slice, <code>&amp;[u8]</code>, and return it as <code>&amp;[Self]</code> with the same lifetime. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.from_byte_slice_unchecked" class="method trait-impl"><a href="#method.from_byte_slice_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">from_byte_slice_unchecked</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>]) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.slice.html">[Self]</a></h4></section></summary><div class='docblock'>Takes a byte slice, <code>&amp;[u8]</code>, and return it as <code>&amp;[Self]</code> with the same lifetime, assuming
that this byte slice has previously been run through [<code>Self::parse_byte_slice()</code>] with
success. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_byte_slice" class="method trait-impl"><a href="#method.as_byte_slice" class="anchor">§</a><h4 class="code-header">fn <a class="fn">as_byte_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.slice.html">[Self]</a>) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Given <code>&amp;[Self]</code>, returns a <code>&amp;[u8]</code> with the same lifetime. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; ZeroMapKV&lt;'a&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Container" class="associatedtype trait-impl"><a href="#associatedtype.Container" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Container</a> = ZeroVec&lt;'a, <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt;</h4></section></summary><div class='docblock'>The container that can be used with this type: [<code>ZeroVec</code>] or [<code>VarZeroVec</code>].</div></details><section id="associatedtype.Slice" class="associatedtype trait-impl"><a href="#associatedtype.Slice" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Slice</a> = ZeroSlice&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt;</h4></section><details class="toggle" open><summary><section id="associatedtype.GetType" class="associatedtype trait-impl"><a href="#associatedtype.GetType" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">GetType</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The type produced by <code>Container::get()</code> <a>Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.OwnedType" class="associatedtype trait-impl"><a href="#associatedtype.OwnedType" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">OwnedType</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The type produced by <code>Container::replace()</code> and <code>Container::remove()</code>,
also used during deserialization. If <code>Self</code> is human readable serialized,
deserializing to <code>Self::OwnedType</code> should produce the same value once
passed through <code>Self::owned_as_self()</code> <a>Read more</a></div></details></div></details><section id="impl-Copy-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Copy-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Eq-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Eq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-StructuralEq-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-StructuralEq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Send-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Send-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Sync-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Sync-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Unpin-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Unpin-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-UnwindSafe-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-UnwindSafe-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct boa_temporal::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.75.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.75.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#766">source</a><a href="#method.from-9" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Serialize-for-T" class="impl"><a class="src rightside" href="https://docs.rs/erased-serde/0.3.31/src/erased_serde/ser.rs.html#235-237">source</a><a href="#impl-Serialize-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/erased-serde/0.3.31/erased_serde/ser/trait.Serialize.html" title="trait erased_serde::ser::Serialize">Serialize</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.195/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><section id="method.erased_serialize" class="method trait-impl"><a class="src rightside" href="https://docs.rs/erased-serde/0.3.31/src/erased_serde/ser.rs.html#239">source</a><a href="#method.erased_serialize" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/erased-serde/0.3.31/erased_serde/ser/trait.Serialize.html#tymethod.erased_serialize" class="fn">erased_serialize</a>(&amp;self, serializer: &amp;mut dyn <a class="trait" href="https://docs.rs/erased-serde/0.3.31/erased_serde/ser/trait.Serializer.html" title="trait erased_serde::ser::Serializer">Serializer</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://docs.rs/erased-serde/0.3.31/erased_serde/ser/struct.Ok.html" title="struct erased_serde::ser::Ok">Ok</a>, <a class="struct" href="https://docs.rs/erased-serde/0.3.31/erased_serde/error/struct.Error.html" title="struct erased_serde::error::Error">Error</a>&gt;</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.75.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/alloc/string.rs.html#2600">source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/alloc/string.rs.html#2606">source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.75.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.75.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.75.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.75.0/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.75.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-DeserializeOwned-for-T" class="impl"><a class="src rightside" href="https://docs.rs/serde/1.0.195/src/serde/de/mod.rs.html#608">source</a><a href="#impl-DeserializeOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/serde/1.0.195/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> for T<span class="where fmt-newline">where
    T: for&lt;'de&gt; <a class="trait" href="https://docs.rs/serde/1.0.195/serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt;,</span></h3></section><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<span class="where fmt-newline">where
    T: 'static,</span></h3></section><section id="impl-MaybeSendSync-for-T" class="impl"><a href="#impl-MaybeSendSync-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; MaybeSendSync for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.u8.html\">u8</a>]</span>"}</script></section></div></main></body></html>