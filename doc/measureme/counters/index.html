<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Profiling counters and their implementation."><meta name="keywords" content="rust, rustlang, rust-lang, counters"><title>measureme::counters - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../measureme/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../measureme/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module counters</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div></section><div id="sidebar-vars" data-name="counters" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../measureme/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../index.html">measureme</a>::<wbr><a class="mod" href="#">counters</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/measureme/counters.rs.html#1-999">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Profiling counters and their implementation.</p>
<h2 id="available-counters"><a href="#available-counters">Available counters</a></h2><div><table><thead><tr><th>Name (for <a href="enum.Counter.html#method.by_name" title="Counter::by_name()"><code>Counter::by_name()</code></a>)</th><th>Counter</th><th>OSes</th><th>CPUs</th></tr></thead><tbody>
<tr><td><code>wall-time</code></td><td><a href="struct.WallTime.html" title="WallTime"><code>WallTime</code></a></td><td>any</td><td>any</td></tr>
<tr><td><code>instructions:u</code></td><td><a href="struct.Instructions.html" title="Instructions"><code>Instructions</code></a></td><td>Linux</td><td><code>x86_64</code></td></tr>
<tr><td><code>instructions-minus-irqs:u</code></td><td><a href="struct.InstructionsMinusIrqs.html" title="InstructionsMinusIrqs"><code>InstructionsMinusIrqs</code></a></td><td>Linux</td><td><code>x86_64</code><br>- AMD (since K8)<br>- Intel (since Sandy Bridge)</td></tr>
<tr><td><code>instructions-minus-r0420:u</code></td><td><a href="struct.InstructionsMinusRaw0420.html" title="InstructionsMinusRaw0420"><code>InstructionsMinusRaw0420</code></a></td><td>Linux</td><td><code>x86_64</code><br>- AMD (Zen)</td></tr>
</tbody></table>
</div>
<p><em>Note: <code>:u</code> suffixes for hardware performance counters come from the Linux <code>perf</code>
tool, and indicate that the counter is only active while userspace code executes
(i.e. it’s paused while the kernel handles syscalls, interrupts, etc.).</em></p>
<h2 id="limitations-and-caveats"><a href="#limitations-and-caveats">Limitations and caveats</a></h2>
<p><em>Note: for more information, also see the GitHub PR which first implemented hardware
performance counter support (<a href="https://github.com/rust-lang/measureme/pull/143">#143</a>).</em></p>
<p>The hardware performance counters (i.e. all counters other than <code>wall-time</code>) are limited to:</p>
<ul>
<li>Linux, for out-of-the-box performance counter reads from userspace
<ul>
<li>other OSes could work through custom kernel extensions/drivers, in the future</li>
</ul>
</li>
<li><code>x86_64</code> CPUs, mostly due to lack of other available test hardware
<ul>
<li>new architectures would be easier to support (on Linux) than new OSes</li>
<li>easiest to add would be 32-bit <code>x86</code> (aka <code>i686</code>), which would reuse
most of the <code>x86_64</code> CPU model detection logic</li>
</ul>
</li>
<li>specific (newer) CPU models, for certain non-standard counters
<ul>
<li>e.g. <code>instructions-minus-irqs:u</code> requires a “hardware interrupts” (aka “IRQs”)
counter, which is implemented differently between vendors / models (if at all)</li>
</ul>
</li>
<li>single-threaded programs (counters only work on the thread they were created on)
<ul>
<li>for profiling <code>rustc</code>, this means only “check mode” (<code>--emit=metadata</code>),
is supported currently (<code>-Z no-llvm-threads</code> could also work)</li>
<li>unclear what the best approach for handling multiple threads would be</li>
<li>changing the API (e.g. to require per-thread profiler handles) could result
in a more efficient implementation, but would also be less ergonomic</li>
<li>profiling data from multithreaded programs would be harder to use due to
noise from synchronization mechanisms, non-deterministic work-stealing, etc.</li>
</ul>
</li>
</ul>
<p>For ergonomic reasons, the public API doesn’t vary based on <code>features</code> or target.
Instead, attempting to create any unsupported counter will return <code>Err</code>, just
like it does for any issue detected at runtime (e.g. incompatible CPU model).</p>
<p>When counting instructions specifically, these factors will impact the profiling quality:</p>
<ul>
<li>high-level non-determinism (e.g. user interactions, networking)
<ul>
<li>the ideal use-case is a mostly-deterministic program, e.g. a compiler like <code>rustc</code></li>
<li>if I/O can be isolated to separate profiling events, and doesn’t impact
execution in a more subtle way (see below), the deterministic parts of
the program can still be profiled with high accuracy</li>
<li>intentional uses of randomness may change execution paths, though for
cryptographic operations specifically, “constant time” implementations
are preferred / necessary (in order to limit an external observer’s
ability to infer secrets), so they’re not as much of a problem</li>
<li>even otherwise-deterministic machine-local communication (to e.g. system
services or drivers) can behave unpredictably (especially under load)
<ul>
<li>while we haven’t observed this in the wild yet, it’s possible for
file reads/writes to be split up into multiple smaller chunks
(and therefore take more userspace instructions to fully read/write)</li>
</ul>
</li>
</ul>
</li>
<li>low-level non-determinism (e.g. ASLR, randomized <code>HashMap</code>s, timers)
<ul>
<li>ASLR (“Address Space Layout Randomization”), may be provided by the OS for
security reasons, or accidentally caused through allocations that depend on
random data (even as low-entropy as e.g. the base 10 length of a process ID)</li>
<li>on Linux ASLR can be disabled by running the process under <code>setarch -R</code></li>
<li>this impacts <code>rustc</code> and LLVM, which rely on keying <code>HashMap</code>s by addresses
(typically of interned data) as an optimization, and while non-determinstic
outputs are considered bugs, the instructions executed can still vary a lot,
even when the externally observable behavior is perfectly repeatable</li>
<li><code>HashMap</code>s are involved in one more than one way:
<ul>
<li>both the executed instructions, and the shape of the allocations depend
on both the hasher state and choice of keys (as the buckets are in
a flat array indexed by some of the lower bits of the key hashes)</li>
<li>so every <code>HashMap</code> with keys being/containing addresses will amplify
ASLR and ASLR-like effects, making the entire program more sensitive</li>
<li>the default hasher is randomized, and while <code>rustc</code> doesn’t use it,
proc macros can (and will), and it’s harder to disable than Linux ASLR</li>
</ul>
</li>
<li>most ways of measuring time will inherently never perfectly align with
exact points in the program’s execution, making time behave like another
low-entropy source of randomness - this also means timers will elapse at
unpredictable points (which can further impact the rest of the execution)
<ul>
<li>this includes the common thread scheduler technique of preempting the
currently executing thread with a periodic timer interrupt, so the exact
interleaving of multiple threads will likely not be reproducible without
special OS configuration, or tools that emulate a deterministic scheduler</li>
<li><code>jemalloc</code> (the allocator used by <code>rustc</code>, at least in official releases)
has a 10 second “purge timer”, which can introduce an ASLR-like effect,
unless disabled with <code>MALLOC_CONF=dirty_decay_ms:0,muzzy_decay_ms:0</code></li>
</ul>
</li>
</ul>
</li>
<li>hardware flaws (whether in the design or implementation)
<ul>
<li>hardware interrupts (“IRQs”) and exceptions (like page faults) cause
overcounting (1 instruction per interrupt, possibly the <code>iret</code> from the
kernel handler back to the interrupted userspace program)
<ul>
<li>this is the reason why <code>instructions-minus-irqs:u</code> should be preferred
to <code>instructions:u</code>, where the former is available</li>
<li>there are system-wide options (e.g. <code>CONFIG_NO_HZ_FULL</code>) for removing
some interrupts from the cores used for profiling, but they’re not as
complete of a solution, nor easy to set up in the first place</li>
</ul>
</li>
<li>AMD Zen CPUs have a speculative execution feature (dubbed <code>SpecLockMap</code>),
which can cause non-deterministic overcounting for instructions following
an atomic instruction (such as found in heap allocators, or <code>measureme</code>)
<ul>
<li>this is automatically detected, with a <code>log</code> message pointing the user
to <a href="https://github.com/mozilla/rr/wiki/Zen">https://github.com/mozilla/rr/wiki/Zen</a> for guidance on how to
disable <code>SpecLockMap</code> on their system (sadly requires root access)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Even if some of the above caveats apply for some profiling setup, as long as
the counters function, they can still be used, and compared with <code>wall-time</code>.
Chances are, they will still have less variance, as everything that impacts
instruction counts will also impact any time measurements.</p>
<p>Also keep in mind that instruction counts do not properly reflect all kinds
of workloads, e.g. SIMD throughput and cache locality are unaccounted for.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Instructions.html" title="measureme::counters::Instructions struct">Instructions</a></div><div class="item-right docblock-short"><p>“Instructions retired” hardware performance counter (userspace-only).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InstructionsMinusIrqs.html" title="measureme::counters::InstructionsMinusIrqs struct">InstructionsMinusIrqs</a></div><div class="item-right docblock-short"><p>More accurate <a href="struct.Instructions.html" title="Instructions"><code>Instructions</code></a> (subtracting hardware interrupt counts).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InstructionsMinusRaw0420.html" title="measureme::counters::InstructionsMinusRaw0420 struct">InstructionsMinusRaw0420</a></div><div class="item-right docblock-short"><p>(Experimental) Like <a href="struct.InstructionsMinusIrqs.html" title="InstructionsMinusIrqs"><code>InstructionsMinusIrqs</code></a> (but using an undocumented <code>r0420:u</code> counter).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WallTime.html" title="measureme::counters::WallTime struct">WallTime</a></div><div class="item-right docblock-short"><p>“Monotonic clock” with nanosecond precision (using <a href="https://doc.rust-lang.org/1.61.0/std/time/struct.Instant.html" title="std::time::Instant"><code>std::time::Instant</code></a>).</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Counter.html" title="measureme::counters::Counter enum">Counter</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="measureme" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>